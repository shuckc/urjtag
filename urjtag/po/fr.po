# Messages français pour GNU concernant jtag.
# Copyright © 2004 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, traducteur depuis/since 1996.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU jtag 0.5.1\n"
"Report-Msgid-Bugs-To: marcel@telka.sk\n"
"POT-Creation-Date: 2021-01-24 08:52+0100\n"
"PO-Revision-Date: 2004-05-10 08:00-0500\n"
"Last-Translator: Michel Robitaille <robitail@IRO.UMontreal.CA>\n"
"Language-Team: French <traduc@traduc.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: src/apps/jtag/jtag.c:369
#, c-format
msgid "'%s' must not be run suid root!\n"
msgstr ""

#: src/apps/jtag/jtag.c:428
#, fuzzy, c-format
msgid "%s #%s\n"
msgstr "%-13s %s\n"

#: src/apps/jtag/jtag.c:431
#, c-format
msgid "Usage: %s [OPTIONS] [FILE [FILE ... ]] \n"
msgstr ""

#: src/apps/jtag/jtag.c:434
#, c-format
msgid "  -h, --help          display this help and exit\n"
msgstr ""

#: src/apps/jtag/jtag.c:435
#, c-format
msgid "  -v, --version       display version information and exit\n"
msgstr ""

#: src/apps/jtag/jtag.c:437
#, c-format
msgid "  -n, --norc          disable reading ~/.jtag/rc on startup\n"
msgstr ""

#: src/apps/jtag/jtag.c:438
#, c-format
msgid "  -i, --interactive   enter interactive mode after reading files\n"
msgstr ""

#: src/apps/jtag/jtag.c:439
#, c-format
msgid "  -q, --quiet         Do not print help on startup\n"
msgstr ""

#: src/apps/jtag/jtag.c:441
#, c-format
msgid "  [FILE]              file containing commands to execute\n"
msgstr ""

#: src/apps/jtag/jtag.c:444
#, c-format
msgid "  Please report bugs at http://www.urjtag.org\n"
msgstr ""

#: src/apps/jtag/jtag.c:451
#, c-format
msgid ""
"\n"
"%s #%s\n"
"\n"
"Copyright (C) 2002, 2003 ETC s.r.o.\n"
"Copyright (C) 2007, 2008, 2009 Kolja Waschk and the respective authors\n"
msgstr ""

#: src/apps/jtag/jtag.c:456
#, c-format
msgid ""
"\n"
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2 of the License, or\n"
"(at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
msgstr ""

#: src/apps/jtag/jtag.c:482 src/apps/jtag/jtag.c:505 src/apps/jtag/jtag.c:528
#, c-format
msgid "Out of memory\n"
msgstr "Mémoire épuisée\n"

#: src/apps/jtag/jtag.c:490
#, c-format
msgid "Unable to open file `%s'!\n"
msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#: src/apps/jtag/jtag.c:517
#, fuzzy, c-format
msgid ""
"\n"
"%s #%s\n"
"Copyright (C) 2002, 2003 ETC s.r.o.\n"
"Copyright (C) 2007, 2008, 2009 Kolja Waschk and the respective authors\n"
"\n"
"%s is free software, covered by the GNU General Public License, and you are\n"
"welcome to change it and/or distribute copies of it under certain "
"conditions.\n"
"There is absolutely no warranty for %s.\n"
"\n"
msgstr ""
"%s\n"
"Copyright © 2002, 2003 ETC s.r.o.\n"
"%s est un logiciel libre; vous pouvez le redistribuer ou le\n"
"modifier selon les termes de la License Publique Générale de GNU, publiée\n"
"par la Free Software Foundation (soit la version 2 ou selon votre choix, "
"toute version ultérieure).\n"
"\n"
"Ce programme est distribué dans l'espoir qu'il soit utile,\n"
"mais AUCUNE garantie n'est donnée pour %s\n"
"tant pour des raisons COMMERCIALES que\n"
"pour RÉPONDRE À UN BESOIN PARTICULIER.  Consulter la licence\n"
"GNU General Public License pour plus de détails.\n"
"\n"
"Vous devriez avoir reçu copie de la Licence Publique Générale de GNU\n"
"avec ce programme; sinon, écrire à la Free Software Foundation, Inc.,\n"
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"

#: src/apps/jtag/jtag.c:534
#, fuzzy, c-format
msgid "%s may damage your hardware!\n"
msgstr ""
"AVERTISSEMENT: %s peut endommager votre matériel! Taper \"quit\" pour "
"quitter!\n"
"\n"

#: src/apps/jtag/jtag.c:536
#, fuzzy
msgid ""
"Type \"quit\" to exit, \"help\" for help.\n"
"\n"
msgstr ""
"Taper \"help\" pour de l'aide.\n"
"\n"

#: src/bsdl/bsdl_bison.y:270
msgid "Unsupported BSDL construct found"
msgstr ""

#: src/bsdl/bsdl_bison.y:333
msgid "Error in Instruction_Opcode attribute statement"
msgstr ""

#: src/bsdl/bsdl_bison.y:346
msgid "Multiple opcode patterns are not supported, first pattern will be used"
msgstr ""

#: src/bsdl/bsdl_bison.y:377
msgid "Error in Opcode List"
msgstr ""

#: src/bsdl/bsdl_bison.y:463
msgid "Error in Boundary Cell description"
msgstr ""

#: src/bsdl/bsdl_bison.y:588
#, fuzzy
msgid "Error in ISC_Pin_Behavior Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:600
#, fuzzy
msgid "Error in ISC_Fixed_System_Pins Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:627
#, fuzzy
msgid "Error in ISC_Security Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:661
#, fuzzy
msgid "Error in ISC_Flow Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:825
#, fuzzy
msgid "Error in ISC_Procedure Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:849
#, fuzzy
msgid "Error in ISC_Action Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/bsdl_bison.y:892 src/bsdl/bsdl_bison.y:906
#: src/bsdl/vhdl_bison.y:676
#, c-format
msgid "Line %d, %s.\n"
msgstr ""

#: src/bsdl/bsdl.c:117
#, c-format
msgid "Reading file '%s'\n"
msgstr ""

#: src/bsdl/bsdl.c:138
#, c-format
msgid "BSDL file '%s' passed VHDL stage correctly\n"
msgstr ""

#: src/bsdl/bsdl.c:145
#, c-format
msgid "BSDL file '%s' passed BSDL stage correctly\n"
msgstr ""

#: src/bsdl/bsdl.c:152
#, c-format
msgid "BSDL file '%s' contains errors in VHDL stage, stopping\n"
msgstr ""

#: src/bsdl/bsdl.c:293 src/tap/detect.c:418
#, c-format
msgid "  Filename:     %s\n"
msgstr "  nom de fichier:     %s\n"

#: src/bsdl/bsdl.c:305
#, fuzzy, c-format
msgid "Cannot open directory %s\n"
msgstr "ne peut ouvrir %s\n"

#: src/bsdl/bsdl_sem.c:204
msgid "No IDCODE specification found.\n"
msgstr ""

#: src/bsdl/bsdl_sem.c:662
msgid "IDCODE matched\n"
msgstr ""

#: src/bsdl/bsdl_sem.c:664
msgid "IDCODE mismatch\n"
msgstr ""

#: src/bsdl/bsdl_sem.c:712
msgid "BSDL stage reported errors, aborting.\n"
msgstr ""

#: src/bsdl/bsdl_sem.c:719
#, c-format
msgid "Got IDCODE: %s\n"
msgstr ""

#: src/bsdl/vhdl_bison.y:233
msgid "Improper Entity declaration"
msgstr ""

#: src/bsdl/vhdl_bison.y:234
msgid "Check if source file is BSDL"
msgstr ""

#: src/bsdl/vhdl_bison.y:244 src/bsdl/vhdl_bison.y:252
#, fuzzy
msgid "Syntax Error"
msgstr "ERREUR de syntaxe!\n"

#: src/bsdl/vhdl_bison.y:262
msgid "Improper Port declaration"
msgstr ""

#: src/bsdl/vhdl_bison.y:294
#, fuzzy
msgid "Error in Package declaration(s)"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:319
#, fuzzy
msgid "Error in Standard Package"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:337
#, fuzzy
msgid "Error in Standard Declarations"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:348
#, fuzzy
msgid "Error in Attribute type identification"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:364
#, fuzzy
msgid "Error in Type definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:380
#, fuzzy
msgid "Error in Bit definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:391
#, fuzzy
msgid "Error in Record Definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:404
#, fuzzy
msgid "Error in defered constant"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:416
#, fuzzy
msgid "Error in Package Body definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:428
#, fuzzy
msgid "Error in Cell Constant definition"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:439
#, fuzzy
msgid "Error in Cell Data Record"
msgstr "Error: échec de la connexion par cable!\n"

#: src/bsdl/vhdl_bison.y:448
#, fuzzy
msgid "Error in Cell_Type Function field"
msgstr "Error: échec de la connexion par cable!\n"

#: src/bsdl/vhdl_bison.y:455
#, fuzzy
msgid "Error in BScan_Inst Instruction field"
msgstr "Error: échec de la connexion par cable!\n"

#: src/bsdl/vhdl_bison.y:462
#, fuzzy
msgid "Error in Constant CAP data source field"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:486
#, fuzzy
msgid "Error in User-Defined Package declarations"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:493
msgid "Unknown VHDL statement"
msgstr ""

#: src/bsdl/vhdl_bison.y:516
#, fuzzy
msgid "Error in Attribute specification"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/bsdl/vhdl_bison.y:671
#, c-format
msgid "In Package %s, Line %d, %s.\n"
msgstr ""

#: src/bsdl/vhdl_bison.y:689
msgid "Too many errors"
msgstr ""

#: src/bus/arm9tdmi.c:89
#, fuzzy, c-format
msgid "ARM9TDMI compatible bus driver (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/arm9tdmi.c:369
#, fuzzy
msgid "SCANN register"
msgstr "Registre"

#: src/bus/arm9tdmi.c:375
#, fuzzy
msgid "SCAN1 register"
msgstr "Registre"

#: src/bus/arm9tdmi.c:381
#, fuzzy
msgid "SCAN2 register"
msgstr "Registre"

#: src/bus/arm9tdmi.c:420 src/bus/ejtag.c:551
#, c-format
msgid "Failed to enter debug mode, ctrl=%s"
msgstr ""

#: src/bus/arm9tdmi.c:426
msgid "The target is halted in "
msgstr ""

#: src/bus/arm9tdmi.c:428
msgid "THUMB mode.\n"
msgstr ""

#: src/bus/arm9tdmi.c:430
msgid "ARM mode.\n"
msgstr ""

#: src/bus/arm9tdmi.c:555
#, fuzzy
msgid "ARM9TDMI compatible bus driver"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/au1500.c:124
#, fuzzy, c-format
msgid "AU1500 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/au1500.c:301
msgid "AU1500 BUS Driver via BSR"
msgstr ""

#: src/bus/avr32.c:153
#, fuzzy, c-format
msgid "%s: instr=%s\n"
msgstr "%-13s %s\n"

#: src/bus/avr32.c:158
#, fuzzy, c-format
msgid "%s: ret=%s\n"
msgstr "%-13s %s\n"

#: src/bus/avr32.c:172
#, fuzzy, c-format
msgid "%s: data=%s\n"
msgstr "%-13s %s\n"

#: src/bus/avr32.c:175
#, c-format
msgid "%s: data out=%s\n"
msgstr ""

#: src/bus/avr32.c:196
#, c-format
msgid "%s: slave=%01x, addr=%08lx, %s\n"
msgstr ""

#: src/bus/avr32.c:222 src/bus/avr32.c:248 src/bus/avr32.c:322
#: src/bus/avr32.c:334
#, fuzzy, c-format
msgid "%s: data=%08lx\n"
msgstr "%-13s %s\n"

#: src/bus/avr32.c:292
#, fuzzy, c-format
msgid "%s: addr=%08lx, mode=%s\n"
msgstr "adr: 0x%08X"

#: src/bus/avr32.c:383
#, fuzzy, c-format
msgid "%s: read status %08lx\n"
msgstr "%s: état invalide: %2X\n"

#: src/bus/avr32.c:417
#, fuzzy, c-format
msgid "%s: status=%08lx\n"
msgstr "%s: état invalide: %2X\n"

#: src/bus/avr32.c:613
#, fuzzy, c-format
msgid "AVR32 multi-mode bus driver (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/avr32.c:695
#, fuzzy, c-format
msgid "%s:addr=%08lx\n"
msgstr "adr: 0x%08X"

#: src/bus/avr32.c:806
msgid ""
"Atmel AVR32 multi-mode bus driver, requires <mode> parameter\n"
"           valid <mode> parameters:\n"
"               x8:   8 bit bus for the uncached HSB area, via OCD registers\n"
"               x16:  16 bit bus for the uncached HSB area, via OCD "
"registers\n"
"               x32:  32 bit bus for the uncached HSB area, via OCD "
"registers\n"
"               OCD : 32 bit bus for the OCD registers\n"
"               HSBC: 32 bit bus for the cached HSB area, via SAB\n"
"               HSBU: 32 bit bus for the uncached HSB area, via SAB"
msgstr ""

#: src/bus/bcm1250.c:115
#, c-format
msgid "Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#: src/bus/bcm1250.c:525
msgid "Broadcom BCM1250 compatible bus driver via BSR"
msgstr "pilote de bus compatible Broadcom BCM1250 via BSR"

#: src/bus/bscoach.c:137
#, fuzzy, c-format
msgid ""
"Goepel electronic Boundary Scan Coach compatible bus driver via BSR (JTAG "
"part No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7727 via BSR (JTAG no de pièce %d)\n"

#: src/bus/bscoach.c:378
msgid ""
"Goepel Boundary Scan Coach compatible bus driver for flash programming via "
"BSR"
msgstr ""

#: src/bus/buses.c:76 src/bus/buses.c:113
#, c-format
msgid "realloc(%s,%zd) fails"
msgstr ""

#: src/bus/buses.c:136
#, fuzzy
msgid "invalid bus number"
msgstr "%s: numéro de bus invalide\n"

#: src/bus/buses.c:216
#, fuzzy, c-format
msgid "Initialized bus %d, active bus %d\n"
msgstr "initialiser le pilote du bus pour la pièce active."

#: src/bus/ejtag.c:137
#, fuzzy, c-format
msgid "EJTAG compatible bus driver via PrAcc (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/ejtag.c:168
msgid "EJADDRESS, EJDATA or EJCONTROL register not found"
msgstr ""

#: src/bus/ejtag.c:189
#, c-format
msgid "Reset occurred, ctrl=%s"
msgstr ""

#: src/bus/ejtag.c:196
#, c-format
msgid "No processor access, ctrl=%s"
msgstr ""

#: src/bus/ejtag.c:210
#, c-format
msgid "PrAcc bad alignment: addr=0x%08lx"
msgstr ""

#: src/bus/ejtag.c:225
#, c-format
msgid "%s(%d) PrAcc write: addr=0x%08lx data=0x%08lx\n"
msgstr ""

#: src/bus/ejtag.c:236
#, c-format
msgid "Unknown write addr=0x%08lx data=0x%08lx"
msgstr ""

#: src/bus/ejtag.c:296
msgid "EJCONTROL or EJIMPCODE register not found"
msgstr ""

#: src/bus/ejtag.c:358
msgid "EJADDRESS or EJDATA register not found"
msgstr ""

#: src/bus/ejtag.c:766
#, fuzzy
msgid "EJTAG compatible bus driver via PrAcc"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/fjmem.c:108 src/part/part.c:355
#, fuzzy
msgid "invalid instruction length"
msgstr "longueur d'instruction invalide\n"

#: src/bus/fjmem.c:397
msgid "Parameter for instruction opcode missing"
msgstr ""

#: src/bus/fjmem.c:475
#, fuzzy, c-format
msgid "fjmem FPGA bus driver via USER register (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/fjmem.c:610 src/bus/fjmem.c:645 src/bus/fjmem.c:680
#: src/bus/fjmem.c:716 src/bus/jopcyc.c:557 src/bus/jopcyc.c:596
#: src/bus/jopcyc.c:628 src/bus/jopcyc.c:662 src/bus/zefant-xs3.c:707
#: src/bus/zefant-xs3.c:780 src/bus/zefant-xs3.c:831 src/bus/zefant-xs3.c:887
msgid "Address out of range"
msgstr ""

#: src/bus/fjmem.c:733
msgid ""
"FPGA JTAG memory bus driver via USER register, requires parameters:\n"
"           opcode=<USERx OPCODE> [len=<FJMEM REG LEN>]"
msgstr ""

#: src/bus/ixp425.c:117
#, c-format
msgid "Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel IXP425 via BSR (JTAG No de pièce %d)\n"

#: src/bus/ixp425.c:290
msgid "Intel IXP425 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/jopcyc.c:344
#, fuzzy, c-format
msgid ""
"JOP.design Cyclone Board compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#: src/bus/jopcyc.c:694
#, fuzzy
msgid "JOP.design Cyclone Board compatible bus driver via BSR"
msgstr "pilote de bus compatible Broadcom BCM1250 via BSR"

#: src/bus/lh7a400.c:139
#, fuzzy, c-format
msgid "Sharp LH7A400 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7750R via BSR (JTAG no de pièce %d)\n"

#: src/bus/lh7a400.c:327
#, fuzzy
msgid "Sharp LH7A400 compatible bus driver via BSR (flash access only!)"
msgstr ""
"pilote de bus compatible Hitachi SH7750R via BSR (JTAG no de pièce %d)\n"

#: src/bus/mpc5200.c:157
#, fuzzy, c-format
msgid "Freescale MPC5200 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#: src/bus/mpc5200.c:172
msgid "LocalPlus Bus"
msgstr ""

#: src/bus/mpc5200.c:401
#, fuzzy
msgid "Freescale MPC5200 compatible bus driver via BSR, parameter: [mux]"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/mpc824x.c:113
msgid ""
"   Bus width 64 exists in mpc824x, but not supported by UrJTAG currently"
msgstr ""

#: src/bus/mpc824x.c:118
msgid "   Only 8, 16, 32 and 64 bus width are supported for Banks 0 and 1"
msgstr ""

#: src/bus/mpc824x.c:130
msgid ""
"Usage: initbus mpc824x [width=WIDTH] [revbits] [dbgAddr] [dbgData]\n"
"\n"
"   WIDTH      data bus width - 8, 16, 32, 64 (default 8)\n"
"   revbits    reverse bits in data bus (default - no)\n"
"   dbgAddr    display address bus state (default - no)\n"
"   dbgData    display data bus state (default - no)\n"
msgstr ""

#: src/bus/mpc824x.c:156
#, c-format
msgid "   Using default bus width %d\n"
msgstr ""

#: src/bus/mpc824x.c:250
#, fuzzy, c-format
msgid "Motorola MPC824x compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#: src/bus/mpc824x.c:274
msgid "Base ROM Interface (Bank 1)"
msgstr ""

#: src/bus/mpc824x.c:284 src/bus/mpc824x.c:303
msgid "Base ROM Interface (Bank 0)"
msgstr ""

#: src/bus/mpc824x.c:337
#, c-format
msgid "Warning: unhandled bus width: %i"
msgstr ""

#: src/bus/mpc824x.c:363
#, c-format
msgid "Addr    [%2d:0]: %06lX   "
msgstr ""

#: src/bus/mpc824x.c:413
#, c-format
msgid "Data WR [%d:0]: %08lX   "
msgstr ""

#: src/bus/mpc824x.c:461
#, c-format
msgid "Data RD [%d:0]: %08lX   "
msgstr ""

#: src/bus/mpc824x.c:583
#, fuzzy
msgid "Motorola MPC824x compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/mpc837x.c:103
msgid ""
"Usage: initbus mpc837x [mux] [width=WIDTH]\n"
"            MUX        multiplexed data bus (default no)\n"
"            WIDTH      data bus width - 8, 16, 32 (default 8)\n"
msgstr ""

#: src/bus/mpc837x.c:124
msgid "    Only 8, 16, 32 bus width are suported\n"
msgstr ""

#: src/bus/mpc837x.c:139
msgid "    Only 8 and 16 non multiplexed bus width are suported\n"
msgstr ""

#: src/bus/mpc837x.c:216
#, fuzzy, c-format
msgid "Freescale MPC837X compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#: src/bus/mpc837x.c:228
msgid "Local Bus Controller"
msgstr ""

#: src/bus/mpc837x.c:493
#, fuzzy
msgid ""
"Freescale MPC837x compatible bus driver via BSR, parameter: [mux] [width]"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/ppc405ep.c:113
#, fuzzy, c-format
msgid "IBM PowerPC 405EP compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel IXP425 via BSR (JTAG No de pièce %d)\n"

#: src/bus/ppc405ep.c:267
#, fuzzy
msgid "IBM PowerPC 405EP compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/ppc440gx_ebc8.c:113
#, fuzzy, c-format
msgid ""
"IBM PowerPC 440GX 8-bit compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel IXP425 via BSR (JTAG No de pièce %d)\n"

#: src/bus/ppc440gx_ebc8.c:271
#, fuzzy
msgid "IBM PowerPC 440GX 8-bit EBC compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/prototype.c:133
#, c-format
msgid "value %lu not defined for parameter %s"
msgstr ""

#: src/bus/prototype.c:166 src/cmd/cmd_get.c:71 src/cmd/cmd_set.c:98
#: src/cmd/cmd_test.c:75
#, fuzzy, c-format
msgid "signal '%s' not found"
msgstr "signal '%s' non repéré\n"

#: src/bus/prototype.c:210
#, c-format
msgid "parameter %s is unknown"
msgstr ""

#: src/bus/prototype.c:254
msgid "parameters alsb=<signal> and/or amsb=<signal> are not defined"
msgstr ""

#: src/bus/prototype.c:314
msgid "parameters dlsb=<signal> and/or dmsb=<signal> are not defined\n"
msgstr ""

#: src/bus/prototype.c:321
msgid "parameter cs=<signal> or ncs=<signal> is not defined\n"
msgstr ""

#: src/bus/prototype.c:328
msgid "parameter oe=<signal> or noe=<signal> is not defined\n"
msgstr ""

#: src/bus/prototype.c:335
msgid "parameter we=<signal> or nwe=<signal> is not defined\n"
msgstr ""

#: src/bus/prototype.c:361
#, fuzzy, c-format
msgid "Configurable prototype bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/prototype.c:517
msgid ""
"Configurable prototype bus driver via BSR, requires parameters:\n"
"           amsb=<addr MSB> alsb=<addr LSB> dmsb=<data MSB> dlsb=<data LSB>\n"
"           ncs=<CS#>|cs=<CS> noe=<OE#>|oe=<OE> nwe=<WE#>|we=<WE> [amode=auto|"
"x8|x16|x32]"
msgstr ""

#: src/bus/pxa2x0.c:256
#, fuzzy, c-format
msgid "%s (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/pxa2x0.c:327 src/bus/pxa2x0.c:426
msgid "Static Chip Select 0"
msgstr "Sélection statique du module 0"

#: src/bus/pxa2x0.c:397
msgid "Memory Mapped registers (Memory Ctl)"
msgstr "Registres mémoire mappé (Ctl Mémoire)"

#: src/bus/pxa2x0.c:501
msgid "PXA270 internal address space (cfg, SRAM)"
msgstr ""

#: src/bus/pxa2x0.c:521
msgid "PXA270 SDRAM space (4x 64MB)"
msgstr ""

#: src/bus/pxa2x0.c:761
msgid "Intel PXA2x0 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/pxa2x0.c:781
#, fuzzy
msgid "Intel PXA27x compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/readmem.c:55 src/bus/writemem.c:49
#, fuzzy
msgid "Missing bus driver"
msgstr "Erreur: pilote de bus manquant!\n"

#: src/bus/readmem.c:68 src/bus/writemem.c:62
#, fuzzy
msgid "Unknown bus width"
msgstr "Largeur de bus inconnu!\n"

#: src/bus/readmem.c:81 src/bus/writemem.c:75
#, fuzzy, c-format
msgid "address: 0x%08lX\n"
msgstr "adresse: 0x%08X\n"

#: src/bus/readmem.c:83 src/bus/writemem.c:77
#, fuzzy, c-format
msgid "length:  0x%08lX\n"
msgstr "longueur:  0x%08X\n"

#: src/bus/readmem.c:88 src/bus/writemem.c:82
#, fuzzy
msgid "length is 0"
msgstr "longeur est 0.\n"

#: src/bus/readmem.c:94
msgid "reading:\n"
msgstr "lecture en cours:\n"

#: src/bus/readmem.c:120 src/bus/writemem.c:98
#, fuzzy, c-format
msgid "addr: 0x%08llX\r"
msgstr "adr: 0x%08X"

#: src/bus/readmem.c:133 src/bus/writemem.c:145 src/flash/flash.c:262
msgid ""
"\n"
"Done.\n"
msgstr ""
"\n"
"Complété.\n"

#: src/bus/s3c4510x.c:179
#, fuzzy, c-format
msgid ""
"Samsung S3C4510B compatibile bus driver via BSR (JTAG part No. %d) RCS0="
"%ubit\n"
msgstr ""
"pilote de bus compatible Samsung S3C4510B via BSR (JTAG no de pièce %d)\n"

#: src/bus/s3c4510x.c:427
msgid "Samsung S3C4510B compatible bus driver via BSR"
msgstr "pilote de bus compatible Samsung S3C4510B via BSR"

#: src/bus/sa1110.c:124
#, c-format
msgid "Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/sa1110.c:307
msgid "Intel SA-1110 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel SA-1110 via BSR"

#: src/bus/sh7727.c:135
#, c-format
msgid "Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7727 via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7727.c:347
msgid "Hitachi SH7727 compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7727 via BSR"

#: src/bus/sh7750r.c:133
#, c-format
msgid "Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7750R via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7750r.c:328
msgid "Hitachi SH7750R compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7750R via BSR"

#: src/bus/sh7751r.c:127
#, c-format
msgid "Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7751R via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7751r.c:316
msgid "Hitachi SH7751R compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7751R via BSR"

#: src/bus/sharc21065l.c:121
#, fuzzy, c-format
msgid ""
"Analog Device's SHARC 21065L compatible bus driver via BSR (JTAG part No. "
"%d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/sharc21065l.c:135
msgid "Boot Memory Select"
msgstr ""

#: src/bus/sharc21065l.c:316
#, fuzzy
msgid "SHARC_21065L compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel SA-1110 via BSR"

#: src/bus/slsup3.c:169
#, fuzzy, c-format
msgid "SLS UP3 bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/slsup3.c:181
msgid "Flash Memory (2 MByte) byte mode"
msgstr ""

#: src/bus/slsup3.c:191
msgid "SRAM 128KByte (64K x 16)"
msgstr ""

#: src/bus/slsup3.c:201
msgid "LCD Display (RS select by A0)"
msgstr ""

#: src/bus/slsup3.c:440
#, fuzzy
msgid "SLS UP3 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/tx4925.c:137
#, fuzzy, c-format
msgid "Toshiba TX4925 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel IXP425 via BSR (JTAG No de pièce %d)\n"

#: src/bus/tx4925.c:311
#, fuzzy
msgid "Toshiba TX4925 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/writemem.c:88
#, fuzzy
msgid "writing:\n"
msgstr "lecture en cours:\n"

#: src/bus/writemem.c:103
#, c-format
msgid "Short read: bc=0x%zX\n"
msgstr ""

#: src/bus/writemem.c:110
#, fuzzy, c-format
msgid "Unexpected end of file; Addr: 0x%08llX\n"
msgstr "ERREUR: fin prématurée du fichier\n"

#: src/bus/zefant-xs3.c:419
#, fuzzy, c-format
msgid ""
"Simple Solutions Zefant-XS3 Board compatible bus driver via BSR (JTAG part "
"No. %d)\n"
msgstr ""
"pilote de bus compatible Hitachi SH7727 via BSR (JTAG no de pièce %d)\n"

#: src/bus/zefant-xs3.c:756 src/bus/zefant-xs3.c:806 src/bus/zefant-xs3.c:864
#: src/bus/zefant-xs3.c:981
#, fuzzy
msgid "Component type not supported"
msgstr "Flash non supporté!\n"

#: src/bus/zefant-xs3.c:988
#, fuzzy
msgid "Simple Solutions Zefant-XS3 Board compatible bus driver via BSR"
msgstr "pilote de bus compatible Samsung S3C4510B via BSR"

#: src/cmd/cmd_bit.c:92
#, fuzzy, c-format
msgid "%s: unable to get boundary bit number for command '%s'"
msgstr "numéro de bit de limite invalide\n"

#: src/cmd/cmd_bit.c:101
#, fuzzy, c-format
msgid "%s: invalid bit type length for command '%s'"
msgstr "flash: séquence de commande invalide\n"

#: src/cmd/cmd_bit.c:129
#, fuzzy, c-format
msgid "%s: invalid bit type for command '%s'"
msgstr "flash: séquence de commande invalide\n"

#: src/cmd/cmd_bit.c:138
#, fuzzy, c-format
msgid "%s: invalid default value length for command '%s'"
msgstr "flash: séquence de commande invalide\n"

#: src/cmd/cmd_bit.c:153
#, fuzzy, c-format
msgid "%s: invalid default value '%s' for command '%s'"
msgstr "flash: séquence de commande invalide\n"

#: src/cmd/cmd_bit.c:171
#, fuzzy, c-format
msgid "%s: unable to get control bit number for command '%s'"
msgstr "numéro de bit de contrôle invalide\n"

#: src/cmd/cmd_bit.c:179
#, fuzzy, c-format
msgid "%s: invalid control value length for command '%s'"
msgstr "numéro de bit de contrôle invalide\n"

#: src/cmd/cmd_bit.c:204
#, c-format
msgid ""
"Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\n"
"Define new BSR (Boundary Scan Register) bit for SIGNAL, with\n"
"DEFAULT value.\n"
"\n"
"NUMBER        Bit number in the BSR\n"
"TYPE          Bit type, valid values are I, O, B, C, and X\n"
"DEFAULT       Default (safe) bit value, valid values are 1, 0, ?\n"
"SIGNAL        Associated signal name\n"
"CBIT          Control bit number\n"
"CVAL          Control value\n"
"CSTATE        Control state, valid state is only Z\n"
msgstr ""
"Usage: %s NUMÉRO TYPE DÉFAUT SIGNAL [BITC VALC ÉTATC]\n"
"Définir le nouveau bit du registre BSR (Boundary Scan Register) pour le "
"SIGNAL, avec\n"
"la valeur par DÉFAUT.\n"
"\n"
"NUMÉRO        numéro du bit du BSR\n"
"TYPE          type de bit, valeurs permises: I, O, B, C et X\n"
"DÉFAUT        valeur du bit par défaut (sûre), valeurs permises:  1, 0, ?\n"
"SIGNAL        nom du signal associé\n"
"BITC          numéro de bit de contrôle\n"
"VALC          valeur de contrôle\n"
"ÉTATC         état de contrôle, état permis est seulement Z\n"

#: src/cmd/cmd_bit.c:220
msgid "define new BSR bit"
msgstr "définir un nouveau bit BSR"

#: src/cmd/cmd_bsdl.c:158
#, c-format
msgid ""
"Usage: %s path PATHLIST\n"
"Usage: %s test [FILE]\n"
"Usage: %s dump [FILE]\n"
"Usage: %s debug on|off\n"
"Manage BSDL files\n"
"\n"
"PATHLIST semicolon separated list of directory paths to search for BSDL "
"files\n"
"FILE file containing part description in BSDL format\n"
msgstr ""

#: src/cmd/cmd_bsdl.c:171
msgid "manage BSDL files"
msgstr ""

#: src/cmd/cmd_bus.c:92
#, c-format
msgid ""
"Usage: %s BUS\n"
"Change active bus.\n"
"\n"
"BUS           bus number\n"
msgstr ""
"Usage: %s BUS\n"
"Changer le bus actif.\n"
"\n"
"BUS           numéro de bus\n"

#: src/cmd/cmd_bus.c:100
msgid "change active bus"
msgstr "changer le bus actif"

#: src/cmd/cmd_cable.c:66
#, c-format
msgid "%s: automatic probe found nothing"
msgstr ""

#: src/cmd/cmd_cable.c:121
#, c-format
msgid ""
"Usage: %s DRIVER [DRIVER_OPTS]\n"
"Select JTAG cable type.\n"
"\n"
"DRIVER      name of cable\n"
"DRIVER_OPTS options for the selected cable\n"
"\n"
"Type \"cable DRIVER help\" for info about options for cable DRIVER.\n"
"You can also use the driver \"probe\" to attempt autodetection.\n"
"\n"
"List of supported cables:\n"
msgstr ""

#: src/cmd/cmd_cable.c:161
msgid "select JTAG cable"
msgstr "sélectionner le cable JTAG"

#: src/cmd/cmd_cmd.c:296
#, fuzzy, c-format
msgid "%s: Ambiguous command\n"
msgstr "%s: commande inconnue\n"

#: src/cmd/cmd_cmd.c:299 src/cmd/cmd_help.c:67
#, c-format
msgid "%s: unknown command\n"
msgstr "%s: commande inconnue\n"

#: src/cmd/cmd_debug.c:44
#, c-format
msgid "Current log level is '%s'\n"
msgstr ""

#: src/cmd/cmd_debug.c:75
#, c-format
msgid ""
"Usage: %s LEVEL\n"
"Set logging/debugging level.\n"
"\n"
"LEVEL:\n"
"all       every single bit as it is transmitted\n"
"comm      low level communication details\n"
"debug     more details of interest for developers\n"
"detail    verbose output\n"
"normal    just noteworthy info\n"
"warning   unmissable warnings\n"
"error     only fatal errors\n"
"silent    suppress logging output\n"
msgstr ""

#: src/cmd/cmd_debug.c:114
msgid "set logging/debugging level"
msgstr ""

#: src/cmd/cmd_detect.c:62
#, c-format
msgid ""
"Usage: %s\n"
"Detect parts on the JTAG chain.\n"
"\n"
"Output from this command is a list of the detected parts.\n"
"If no parts are detected other commands may not work properly.\n"
msgstr ""
"Usage: %s\n"
"Détecter les pièces sur la chaîne JTAG.\n"
"\n"
"La sortie de cette commande est une liste de pièces détectées.\n"
"Si aucune pièce n'est détectée, les autres commandes peuvent ne pas "
"fonctionner correctement.\n"

#: src/cmd/cmd_detect.c:72
msgid "detect parts on the JTAG chain"
msgstr "pièces détectés sur la caîne JTAG"

#: src/cmd/cmd_detectflash.c:52 src/cmd/cmd_peekpoke.c:57
#: src/cmd/cmd_peekpoke.c:139 src/cmd/cmd_readmem.c:57
#: src/cmd/cmd_writemem.c:55
msgid "Bus missing"
msgstr ""

#: src/cmd/cmd_detectflash.c:66
#, fuzzy, c-format
msgid ""
"Usage: %s ADDRESS\n"
"Detect flash memory type connected to a part.\n"
"\n"
"ADDRESS    Base address for memory region\n"
msgstr ""
"Usage: %s\n"
"Détecter un type de mémoire flash connecté.\n"

#: src/cmd/cmd_detectflash.c:75
msgid "detect parameters of flash chips attached to a part"
msgstr "paramètres de détection de modules flahs connectés"

#: src/cmd/cmd_discovery.c:57
#, c-format
msgid ""
"Usage: %s\n"
"Discovery of unknown parts in the JTAG chain.\n"
"\n"
"'%s' attempts to detect these parameters of an unknown JTAG\n"
"chain:\n"
" 1. IR (instruction register) length\n"
" 2. DR (data register) length for all possible instructions\n"
"\n"
"Warning: This may be dangerous for some parts (especially if the\n"
"part doesn't have TRST signal).\n"
msgstr ""
"Usage: %s\n"
"Découvrir les pièces inconnues sur la chaîne JTAG.\n"
"\n"
"'%s' tentatives pour détecter ces paramètres sur une chaîne JTAG inconnue:\n"
" 1. IR (registre d'instruction register) longueur\n"
" 2. DR (registre de données) longueurs de toutes les instructions possibles\n"
"\n"
"AVERTISSMENT: ceci peut être dangereus pour certaintes pièces (spécialement "
"si celles-ci\n"
"n'ont pas de signal TRST).\n"

#: src/cmd/cmd_discovery.c:72
msgid "discovery of unknown parts in the JTAG chain"
msgstr "découverte des pièces inconnues dans la chaîne JTAG"

#: src/cmd/cmd_dr.c:70
#, fuzzy, c-format
msgid "%s: part without active instruction"
msgstr "%s: pièces sans instruction active\n"

#: src/cmd/cmd_dr.c:77
#, fuzzy, c-format
msgid "%s: instruction without active data register"
msgstr "%s: pièces sans registre actif de données\n"

#: src/cmd/cmd_dr.c:127
#, fuzzy, c-format
msgid ""
"Usage: %1$s [DIR]\n"
"Usage: %1$s BITSTRING\n"
"Usage: %1$s HEXSTRING\n"
"Display input or output data register content or set current register.\n"
"\n"
"DIR              requested data register; possible values: 'in' for\n"
"                 input and 'out' for output; default is 'out'\n"
"BITSTRING        set current data register with BITSTRING (e.g. 01010)\n"
"HEXSTRING        set current data register with HEXSTRING (e.g. 0x123)\n"
msgstr ""
"Usage: %s [DIR]\n"
"Afficher le contenu des registres d'entrée et de sortie de données.\n"
"\n"
"DIR           registre de données interrogé; valeurs possibles: 'in' pour\n"
"                l'entrée et 'out' pour la sortie; par défaut 'out'\n"

#: src/cmd/cmd_dr.c:141
msgid "display active data register for a part"
msgstr "afficher le registre actif de données pour une pièce"

#: src/cmd/cmd_endian.c:97
#, fuzzy, c-format
msgid "Endianness for external files: %s\n"
msgstr ""
"système de poids fort/faible des fichiers externes: gros (big endian)\n"

#: src/cmd/cmd_endian.c:110
#, c-format
msgid "endianness must be 'little' or 'big', not '%s'"
msgstr ""

#: src/cmd/cmd_endian.c:119
#, c-format
msgid ""
"Usage: %s\n"
"Set or print endianness for external files.\n"
msgstr ""
"Usage: %s\n"
"Initialiser ou afficher le système de poids fort/faible (big/little endian) "
"des fichiers externes.\n"

#: src/cmd/cmd_endian.c:141
msgid "set/print endianness"
msgstr ""
"Initialiser ou afficher le système de poids fort/faible (big/little endian)."

#: src/cmd/cmd_eraseflash.c:57 src/cmd/cmd_flashmem.c:60
#: src/cmd/cmd_peekpoke.c:62 src/cmd/cmd_peekpoke.c:144
#, fuzzy
msgid "Bus driver missing"
msgstr "Erreur: pilote du bus manquant.\n"

#: src/cmd/cmd_eraseflash.c:72
#, c-format
msgid ""
"Usage: %s ADDR BLOCKS\n"
"Erase flash memory from ADDR.\n"
"\n"
"ADDR       target addres for erasing block\n"
"BLOCKS     number of blocks to erase\n"
"\n"
"ADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
"Supported Flash Memories:\n"
msgstr ""
"Usage: %s ADR BLOCS\n"
"Effacer la mémoire flash à partir de l'ADResse.\n"
"\n"
"ADR        ADRessse cible pour effacer un bloc\n"
"BLOCS      numbre de blocs à effacer\n"
"\n"
"ADR et BLOCS peuvent être en valeur décimal ou hexadécimal (préfixé avec "
"0x).\n"
"\n"
"Mémoires flash supportées:\n"

#: src/cmd/cmd_eraseflash.c:87
msgid "erase flash memory by number of blocks"
msgstr "effacer la mémoire flash par numéro de bloc"

#: src/cmd/cmd_flashmem.c:76 src/cmd/cmd_writemem.c:66
#, fuzzy, c-format
msgid "Unable to open file `%s'"
msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#: src/cmd/cmd_flashmem.c:94
#, fuzzy, c-format
msgid ""
"Usage: %s ADDR FILENAME [noverify]\n"
"Usage: %s FILENAME [noverify]\n"
"Program FILENAME content to flash memory.\n"
"\n"
"ADDR       target address for raw binary image\n"
"FILENAME   name of the input file\n"
"%-10s FILENAME is in MS .bin format (for WinCE)\n"
"%-10s if specified, verification is skipped\n"
"\n"
"ADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
"Supported Flash Memories:\n"
msgstr ""
"Usage: %s ADR FICHIER\n"
"Usage: %s FICHIER\n"
"Programmer le contenu de la mémoire flash avec le FICHIER.\n"
"\n"
"ADR        ADResse cible d'une image binaire brute\n"
"FICHIER    nom du FICHIER d'entrée\n"
"%-10s FICHIER est un format MS .bin (pour WinCE)\n"
"\n"
"ADR et BLOCS peuvent être en valeur décimal ou hexadécimal (préfixé avec "
"0x).\n"
"\n"
"Mémoires flahs supportées:\n"

#: src/cmd/cmd_flashmem.c:134
msgid "burn flash memory with data from a file"
msgstr "brûler la mémoire flahs avec les données à partir d'un fichier"

#: src/cmd/cmd_frequency.c:55
#, fuzzy, c-format
msgid "Current TCK frequency is %lu Hz\n"
msgstr "Fréquence courant TCK est %u Hz\n"

#: src/cmd/cmd_frequency.c:63
#, fuzzy, c-format
msgid "Setting TCK frequency to %lu Hz\n"
msgstr "Initialisation de la fréquence TCK à %u Hz\n"

#: src/cmd/cmd_frequency.c:74
#, c-format
msgid ""
"Usage: %s [FREQ]\n"
"Change TCK frequency to FREQ or print current TCK frequency.\n"
"\n"
"FREQ is in hertz. It's a maximum TCK frequency for JTAG interface.\n"
"In some cases the TCK frequency is less than FREQ, but the frequency\n"
"is never more than FREQ. Maximum supported frequency depends on JTAG\n"
"adapter.\n"
"\n"
"FREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\n"
"Use 0 for FREQ to disable frequency limit.\n"
msgstr ""
"Usage: %s [FRÉQUENCE]\n"
"Modifier ou afficher la fréquence courante TCK.\n"
"\n"
"FRÉQUENCE est en hertz. C'est la férquence maximale TCK pour une interface "
"JTAG.\n"
"Dans certains cas, la fréquence TCK est inférieure à la FRÉQUENCE mais "
"jamais\n"
"plus que la FRÉQUENCE. La fréquence maximum supportée dépend de l'adapteur "
"JTAG.\n"
"\n"
"FRÉQUENCE doit être un entier non signé. La fréquence minimale permise est 1 "
"Hz.\n"
"Utilise 0 comme valeur pour désactiver la limite de fréquence.\n"

#: src/cmd/cmd_frequency.c:89
msgid "setup JTAG frequency"
msgstr "initialisation de la fréquence JTAG"

#: src/cmd/cmd_get.c:79
#, c-format
msgid "%s = %d\n"
msgstr "%s = %d\n"

#: src/cmd/cmd_get.c:88
#, fuzzy, c-format
msgid ""
"Usage: %s signal SIGNAL\n"
"Get signal state from output BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        signal name (from JTAG declaration file)\n"
msgstr ""
"Usage: %s SIGNAL\n"
"Obtenir l'état du signal de la sortie BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"

#: src/cmd/cmd_get.c:114
msgid "get external signal value"
msgstr "obtenir la valeur externe du signal"

#: src/cmd/cmd_help.c:51
msgid ""
"Command list:\n"
"\n"
msgstr ""
"Liste de commandes:\n"
"\n"

#: src/cmd/cmd_help.c:54
msgid ""
"\n"
"Type \"help COMMAND\" for details about a particular command.\n"
msgstr ""
"\n"
"Taper \"help COMMANDE\" pour des détails au sujet d'une commande "
"particulière.\n"

#: src/cmd/cmd_help.c:76
#, c-format
msgid ""
"Usage: %s [COMMAND]\n"
"Print short help for COMMAND, or list of available commands.\n"
msgstr ""
"Usage: %s [COMMANDE]\n"
"Afficher une aide sommaire de la COMMANDE ou lister les commandes "
"disponibles.\n"

#: src/cmd/cmd_help.c:99
msgid "display this help"
msgstr "afficher l'aide-mémoire"

#: src/cmd/cmd_idcode.c:55
#, c-format
msgid "Reading %lu bytes of idcode\n"
msgstr ""

#: src/cmd/cmd_idcode.c:63
#, c-format
msgid ""
"Usage: %s [BYTES]\n"
"Read [BYTES] IDCODEs of all parts in a JTAG chain.\n"
"\n"
"BYTES must be an unsigned integer, and the default is 0.\n"
"If BYTES is 0, IDCODEs will be read until 32 consecutive zeros are found.\n"
msgstr ""

#: src/cmd/cmd_idcode.c:73
#, fuzzy
msgid "Read IDCODEs of all parts in a JTAG chain"
msgstr "découverte des pièces inconnues dans la chaîne JTAG"

#: src/cmd/cmd_include.c:56
msgid "Please use the 'include' command instead of 'script'\n"
msgstr ""

#: src/cmd/cmd_include.c:80
#, fuzzy, c-format
msgid ""
"Usage: %s FILENAME [n] \n"
"Run command sequence n times from external FILENAME.\n"
"\n"
"FILENAME      Name of the file with commands\n"
msgstr ""
"Usage: %s FICHIER\n"
"Exécuter une séquence de commandes à partir d'un FICHIER externe.\n"
"\n"
"FICHIER        nom du fichier contenant les commande\n"

#: src/cmd/cmd_include.c:108
msgid "include command sequence from external repository"
msgstr "inclure une séquence de commandes à partir du dépôt externe"

#: src/cmd/cmd_include.c:128
msgid "run command sequence from external file"
msgstr "exécuter une séquence de commandes à partir d'un FICHIER externe"

#: src/cmd/cmd_initbus.c:58
#, c-format
msgid ""
"Usage: %s BUSNAME\n"
"Initialize new bus driver for active part.\n"
"\n"
"BUSNAME       Name of the bus\n"
"\n"
"List of available buses:\n"
msgstr ""
"Usage: %s BUS\n"
"Initialiser le pilote du bus pour la pièce active.\n"
"\n"
"BUS           nom du bus\n"
"\n"
"Liste des bus disponibles:\n"

#: src/cmd/cmd_initbus.c:91
msgid "initialize bus driver for active part"
msgstr "initialiser le pilote du bus pour la pièce active."

#: src/cmd/cmd_instruction.c:61
#, fuzzy, c-format
msgid "%s: unknown instruction '%s'"
msgstr "%s: instruction inconnue '%s'\n"

#: src/cmd/cmd_instruction.c:102
#, c-format
msgid ""
"Usage: %s INSTRUCTION\n"
"Usage: %s length LENGTH\n"
"Usage: %s INSTRUCTION CODE REGISTER\n"
"Change active INSTRUCTION for a part or declare new instruction.\n"
"\n"
"INSTRUCTION   instruction name (e.g. BYPASS)\n"
"LENGTH        common instruction length\n"
"CODE          instruction code (e.g. 11111)\n"
"REGISTER      default data register for instruction (e.g. BR)\n"
msgstr ""
"Usage: %s INSTRUCTION\n"
"Usage: %s longueur LONGUEUR\n"
"Usage: %s INSTRUCTION CODE REGISTRE\n"
"Changer l'INSTRUCTION active pour une pièce ou déclarer une nouvelle "
"instruction.\n"
"\n"
"INSTRUCTION   nom de l'instruction (i.e. BYPASS)\n"
"LENGTH        longueur commune d'instruction\n"
"CODE          code d'instruction (i.e. 11111)\n"
"REGISTRE      registre de données pour l'instruction (i.e. BR)\n"

#: src/cmd/cmd_instruction.c:140
msgid "change active instruction for a part or declare new instruction"
msgstr ""
"changer l'instruction active pour une pièce ou déclarer une nouvelle "
"instruction."

#: src/cmd/cmd_part.c:119
#, fuzzy, c-format
msgid "%s: invalid part number %lu, max %d"
msgstr "%s: numéro de pièce invalide\n"

#: src/cmd/cmd_part.c:160
#, fuzzy, c-format
msgid ""
"Usage: %s [PART|ALIAS]\n"
"Change active part for current JTAG chain.\n"
"\n"
"Usage: %s ALIAS\n"
"Assign an alias for the active part.\n"
msgstr ""
"Usage: %s PIÈCE\n"
"Changer la pièce active pour la chaîne courant JTAG.\n"
"\n"
"PIÈCE         numéro de pièce\n"

#: src/cmd/cmd_part.c:169
msgid "change active part for current JTAG chain"
msgstr "changer la pièce active pour la chaîne courante JTAG"

#: src/cmd/cmd_peekpoke.c:80
#, fuzzy, c-format
msgid "URJ_BUS_READ(0x%08lx) = 0x%02lX (%li)\n"
msgstr "bus_read(0x%08x) = 0x%08X (%i)\n"

#: src/cmd/cmd_peekpoke.c:86
#, fuzzy, c-format
msgid "URJ_BUS_READ(0x%08lx) = 0x%04lX (%li)\n"
msgstr "bus_read(0x%08x) = 0x%08X (%i)\n"

#: src/cmd/cmd_peekpoke.c:91
#, fuzzy, c-format
msgid "URJ_BUS_READ(0x%08lx) = 0x%08lX (%li)\n"
msgstr "bus_read(0x%08x) = 0x%08X (%i)\n"

#: src/cmd/cmd_peekpoke.c:104
#, c-format
msgid ""
"Usage: %s ADDR\n"
"Read a single word (bus width size).\n"
"\n"
"ADDR       address to read from\n"
"\n"
"ADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
msgstr ""
"Usage: %s ADR\n"
"Lire un mot simple (taille de la largeur de bus).\n"
"\n"
"ADR        adresse de lecture\n"
"\n"
"ADR peut être en décimal ou hexadécimal (préfixé par 0x).\n"
"\n"

#: src/cmd/cmd_peekpoke.c:116
msgid "read a single word"
msgstr "lire un mot simple"

#: src/cmd/cmd_peekpoke.c:167
#, fuzzy, c-format
msgid ""
"Usage: %s ADDR VAL [ADDR VAL] ... \n"
"Write a single word (bus width size).\n"
"\n"
"ADDR       address to write\n"
"VAL        value to write\n"
"\n"
"ADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
msgstr ""
"Usage: %s ADR VAL\n"
"Écrire un mot simple (taille de la largeur de bus).\n"
"\n"
"ADR        adresse d'écriture\n"
"VAL        valeur à écrire\n"
"\n"
"ADR et VAL peuvent être en décimal ou en hexadécimal (préfixé par 0x).\n"
"\n"

#: src/cmd/cmd_peekpoke.c:180
msgid "write a single word"
msgstr "écrire un mot simple"

#: src/cmd/cmd_pod.c:136
#, c-format
msgid ""
"Usage: %s <TDO|SIGNAL=#> [<TDO|SIGNAL=#> ...]\n"
"Set or read state of POD signal(s).\n"
"TDO is the only signal which may be read.  All other signals,\n"
"if specified, must be set.\n"
"\n"
"SIGNAL           TCK, TMS, TDI, TRST, or RESET\n"
"#                0 or 1\n"
msgstr ""

#: src/cmd/cmd_pod.c:148
msgid "Set or read state of POD signal(s)"
msgstr ""

#: src/cmd/cmd_print.c:123
#, fuzzy, c-format
msgid " Active %%-%ds %%-%ds\n"
msgstr " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/cmd/cmd_print.c:129 src/cmd/cmd_print.c:133 src/cmd/cmd_print.c:138
#: src/cmd/cmd_print.c:172 src/cmd/cmd_print.c:177 src/cmd/cmd_print.c:183
#, c-format
msgid "(%d) String conversion failed!\n"
msgstr "(%d) la conversion de chaîne a échoué!\n"

#: src/cmd/cmd_print.c:130 src/cmd/cmd_print.c:135 src/cmd/cmd_print.c:174
#: src/cmd/cmd_print.c:180
msgid "Instruction"
msgstr "Instruction"

#: src/cmd/cmd_print.c:130 src/cmd/cmd_print.c:135 src/cmd/cmd_print.c:174
#: src/cmd/cmd_print.c:180
msgid "Register"
msgstr "Registre"

#: src/cmd/cmd_print.c:146
#, fuzzy, c-format
msgid "   %%c    %%-%ds %%-%ds\n"
msgstr " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/cmd/cmd_print.c:164
#, fuzzy, c-format
msgid " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"
msgstr " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/cmd/cmd_print.c:173 src/cmd/cmd_print.c:179 src/tap/detect.c:343
msgid "Manufacturer"
msgstr "Manufacturier"

#: src/cmd/cmd_print.c:173 src/cmd/cmd_print.c:179
msgid "Part"
msgstr "Pièce"

#: src/cmd/cmd_print.c:174 src/cmd/cmd_print.c:180
msgid "Stepping"
msgstr "Pas"

#: src/cmd/cmd_print.c:199
#, fuzzy, c-format
msgid " %3d %s "
msgstr " %3d "

#: src/cmd/cmd_print.c:203
#, c-format
msgid " %3d "
msgstr " %3d "

#: src/cmd/cmd_print.c:217
#, c-format
msgid ""
"\n"
"Active bus:\n"
"*%d: "
msgstr ""
"\n"
"Bus actif:\n"
"*%d: "

#: src/cmd/cmd_print.c:227
#, c-format
msgid "Error in bus area discovery at 0x%08llX\n"
msgstr "ERREUR dans la zone de découverte du bus à 0x%08llX\n"

#: src/cmd/cmd_print.c:235
#, fuzzy, c-format
msgid "\tstart: 0x%08lX, length: 0x%08llX, data width: %d bit, (%s)\n"
msgstr ""
"\tdébut: 0x%08X, longueur: 0x%08llX, largeur des données: %d bits, (%s)\n"

#: src/cmd/cmd_print.c:241
#, fuzzy, c-format
msgid "\tstart: 0x%08lX, length: 0x%08llX, data width: %d bit\n"
msgstr "\tdébut: 0x%08X, longueur: 0x%08llX, largeur des données: %d bits\n"

#: src/cmd/cmd_print.c:261
#, c-format
msgid "*%d: "
msgstr "*%d: "

#: src/cmd/cmd_print.c:263
#, c-format
msgid "%d: "
msgstr "%d: "

#: src/cmd/cmd_print.c:274
#, fuzzy, c-format
msgid ""
"Usage: %s [chain|bus|signals|instructions]\n"
"Display JTAG chain status.\n"
"\n"
"Display list of the parts connected to the JTAG chain including\n"
"part number and current (active) instruction and data register.\n"
msgstr ""
"Usage: %s [chaîne|bus]\n"
"Afficher l'état de la chaîne JTAG.\n"
"\n"
"Afficher la liste des pièces connectés à la chaîne JTAG incluant\n"
"le numéro de pièce, l'instruiction courante (active) et le registre de "
"données.\n"

#: src/cmd/cmd_print.c:303
msgid "display JTAG chain list/status"
msgstr "afficher la liste/état de la chaîne JTAG"

#: src/cmd/cmd_quit.c:52
#, c-format
msgid ""
"Usage: %s\n"
"Exit from %s.\n"
msgstr ""
"Usage: %s\n"
"Quitter à partir de %s.\n"

#: src/cmd/cmd_quit.c:57
msgid "exit and terminate this session"
msgstr "quitter et terminer la session"

#: src/cmd/cmd_readmem.c:68
#, fuzzy, c-format
msgid "Unable to create file `%s'"
msgstr "Incapable de créer le fichier `%s'!\n"

#: src/cmd/cmd_readmem.c:81
#, c-format
msgid ""
"Usage: %s ADDR LEN FILENAME\n"
"Copy device memory content starting with ADDR to FILENAME file.\n"
"\n"
"ADDR       start address of the copied memory area\n"
"LEN        copied memory length\n"
"FILENAME   name of the output file\n"
"\n"
"ADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n"
msgstr ""
"Usage: %s ADR LONG FICHIER\n"
"Copier le contenu de la mémoire du périphérique débutant à l'ADR dans le "
"FICHIER.\n"
"\n"
"ADR        adresse de départ de la zone mémoire à copier\n"
"LONG       longeur de la zone mémoire à copier\n"
"FICHIER    nom du fichier de sortie\n"
"\n"
"ADR et LONG peuvent être en décimal ou hexadécimal (préfixe par 0x).\n"

#: src/cmd/cmd_readmem.c:114
msgid "read content of the memory and write it to file"
msgstr "lire le contenu de la mémoire et l'écrire dans le fichier"

#: src/cmd/cmd_register.c:72
#, c-format
msgid ""
"Usage: %s NAME LENGTH\n"
"Define new data register with specified NAME and LENGTH.\n"
"\n"
"NAME          Data register name\n"
"LENGTH        Data register length\n"
msgstr ""
"Usage: %s NOM LONGUEUR\n"
"Définir un nouveau registre de données avec un NOM et une LONGUER "
"spécifique.\n"
"\n"
"NOM           nom du registre de données\n"
"LONGUEUR      longueur du registre de données\n"

#: src/cmd/cmd_register.c:82
msgid "define new data register for a part"
msgstr "définir un nouveau registre de données pour la pièce"

#: src/cmd/cmd_reset.c:58
#, fuzzy, c-format
msgid ""
"Usage: %s\n"
"Reset current JTAG chain.\n"
msgstr "changer la pièce active pour la chaîne courante JTAG"

#: src/cmd/cmd_reset.c:63
#, fuzzy
msgid "reset JTAG chain"
msgstr "sélectionner le cable JTAG"

#: src/cmd/cmd_salias.c:70
#, fuzzy, c-format
msgid "Signal '%s' not found"
msgstr "signal '%s' non repéré\n"

#: src/cmd/cmd_salias.c:89
#, fuzzy, c-format
msgid ""
"Usage: %s ALIAS SIGNAL\n"
"Define new signal ALIAS as alias for existing SIGNAL.\n"
"\n"
"ALIAS         New signal alias name\n"
"SIGNAL        Existing signal name\n"
msgstr ""
"Usage: %s SIGNAL [BROCHES...]\n"
"Définir un nouveau signal avec le nom SIGNAL pour la pièce.\n"
"\n"
"SIGNAL        nouveau nom de signal\n"
"BROCHES       liste debroches pour le signal (non utilisé)\n"

#: src/cmd/cmd_salias.c:110
#, fuzzy
msgid "define an alias for a signal"
msgstr "définir un nouveau signal pour une pièce"

#: src/cmd/cmd_scan.c:71 src/part/part.c:227 src/part/part.c:280
#, fuzzy
msgid "Boundary Scan Register (BSR) not found"
msgstr "%s(%s:%d) Boundary Scan Register (BSR) non repéré\n"

#: src/cmd/cmd_scan.c:85
msgid "Part can't SAMPLE"
msgstr ""

#: src/cmd/cmd_scan.c:115
#, fuzzy, c-format
msgid ": %d > %d\n"
msgstr "%s = %d\n"

#: src/cmd/cmd_scan.c:129
#, c-format
msgid ""
"Usage: %s [SIGNAL]* \n"
"Read BSR and show changes since last scan.\n"
msgstr ""

#: src/cmd/cmd_scan.c:136
msgid "read BSR and show changes since last scan"
msgstr ""

#: src/cmd/cmd_set.c:110
#, fuzzy, c-format
msgid ""
"Usage: %s signal SIGNAL DIR [DATA]\n"
"Set signal state in input BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        signal name (from JTAG declaration file)\n"
"DIR           requested signal direction; possible values: 'in' or 'out'\n"
"DATA          desired output signal value ('0' or '1'); used only if DIR\n"
"                is 'out'\n"
msgstr ""
"Usage: %s SIGNAL DIR [DONNÉE]\n"
"Initialiser l'état du signal à l'entrée du BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"
"DIR           direction requise du signal; valeurs possibles: 'in' ou 'out'\n"
"DATA          valeur de sortie du signal ('0' ou '1'); utilisé seulement si "
"DIR\n"
"                est à 'out'\n"

#: src/cmd/cmd_set.c:157
msgid "set external signal value"
msgstr "initialiser la valeur d'un signal externe"

#: src/cmd/cmd_shell.c:104
#, c-format
msgid ""
"Usage: %s CMD\n"
"Shell out to the OS for a command.\n"
"\n"
"CMD OS Shell Command\n"
msgstr ""

#: src/cmd/cmd_shell.c:112
msgid "run a shell command"
msgstr ""

#: src/cmd/cmd_shift.c:74
#, c-format
msgid ""
"Usage: %s\n"
"Usage: %s\n"
"Shift instruction or data register through JTAG chain.\n"
msgstr ""
"Usage: %s\n"
"Usage: %s\n"
"Décaler le registre d'instruction ou de données à travers la chaîne JTAG.\n"

#: src/cmd/cmd_shift.c:94
msgid "shift data/instruction registers through JTAG chain"
msgstr "décaler le registre instruction/données à travers la chaîne JTAG"

#: src/cmd/cmd_signal.c:66 src/part/signal.c:114
#, fuzzy, c-format
msgid "Signal '%s' already defined"
msgstr "Signal '%s' déjà défini\n"

#: src/cmd/cmd_signal.c:96
#, fuzzy, c-format
msgid ""
"Usage: %s SIGNAL [PIN#]\n"
"Define new signal with name SIGNAL for a part.\n"
"\n"
"SIGNAL           New signal name\n"
"PIN#             List of pin # for a signal\n"
msgstr ""
"Usage: %s SIGNAL [BROCHES...]\n"
"Définir un nouveau signal avec le nom SIGNAL pour la pièce.\n"
"\n"
"SIGNAL        nouveau nom de signal\n"
"BROCHES       liste debroches pour le signal (non utilisé)\n"

#: src/cmd/cmd_signal.c:127
msgid "define new signal for a part"
msgstr "définir un nouveau signal pour une pièce"

#: src/cmd/cmd_svf.c:127
#, c-format
msgid ""
"Usage: %s FILE [stop] [progress] [ref_freq=<frequency>]\n"
"Execute svf commands from FILE.\n"
"stop     : Command execution stops upon TDO mismatch.\n"
"progress : Continually displays progress status.\n"
"ref_freq : Use <frequency> as the reference for 'RUNTEST xxx SEC' commands\n"
"\n"
"FILE file containing SVF commands\n"
msgstr ""

#: src/cmd/cmd_svf.c:138
msgid "execute svf commands from file"
msgstr ""

#: src/cmd/cmd_test.c:93
#, fuzzy, c-format
msgid "<FAIL>%s = %d"
msgstr "%s = %d\n"

#: src/cmd/cmd_test.c:104
#, fuzzy, c-format
msgid ""
"Usage: %s signal SIGNAL 0/1\n"
"Test signal state from output BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        signal name (from JTAG declaration file)\n"
msgstr ""
"Usage: %s SIGNAL\n"
"Obtenir l'état du signal de la sortie BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"

#: src/cmd/cmd_test.c:135
#, fuzzy
msgid "test external signal value"
msgstr "obtenir la valeur externe du signal"

#: src/cmd/cmd_usleep.c:63
#, c-format
msgid ""
"Usage: %s USECS\n"
"Sleep some number of microseconds.\n"
msgstr ""

#: src/cmd/cmd_usleep.c:70
msgid "Sleep some number of microseconds"
msgstr ""

#: src/cmd/cmd_writemem.c:97
#, fuzzy, c-format
msgid ""
"Usage: %s ADDR LEN FILENAME\n"
"Write to device memory starting at ADDR the FILENAME file.\n"
"\n"
"ADDR       start address of the written memory area\n"
"LEN        written memory length\n"
"FILENAME   name of the input file\n"
"\n"
"ADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"NOTE: This is NOT useful for FLASH programming!\n"
msgstr ""
"Usage: %s ADR LONG FICHIER\n"
"Copier le contenu de la mémoire du périphérique débutant à l'ADR dans le "
"FICHIER.\n"
"\n"
"ADR        adresse de départ de la zone mémoire à copier\n"
"LONG       longeur de la zone mémoire à copier\n"
"FICHIER    nom du fichier de sortie\n"
"\n"
"ADR et LONG peuvent être en décimal ou hexadécimal (préfixe par 0x).\n"

#: src/cmd/cmd_writemem.c:111
msgid "write content of file to the memory"
msgstr ""

#: src/flash/amd.c:311
msgid ""
"Chip: AMD Flash\n"
"\tManufacturer: "
msgstr ""
"Module: AMD Flash\n"
"\tManufacturier: "

#: src/flash/amd.c:316 src/flash/amd.c:345 src/flash/amd.c:367
#: src/flash/amd.c:386 src/flash/amd.c:408 src/flash/amd_flash.c:269
msgid ""
"\n"
"\tChip: "
msgstr ""
"\n"
"\tModule: "

#: src/flash/amd.c:339 src/flash/amd.c:361 src/flash/amd.c:380
#: src/flash/amd.c:402 src/flash/amd.c:415 src/flash/amd_flash.c:281
#, c-format
msgid "Unknown (ID 0x%04x)"
msgstr "Inconnu (ID 0x%04x)"

#: src/flash/amd.c:420
#, fuzzy, c-format
msgid "Unknown manufacturer (ID 0x%04x) Chip (ID 0x%04x)"
msgstr "Manufacturier inconnu (ID 0x%04x)"

#: src/flash/amd.c:424 src/flash/amd_flash.c:284
#, c-format
msgid ""
"\n"
"\tProtected: %04x\n"
msgstr ""
"\n"
"\tProtégé: %04x\n"

#: src/flash/amd.c:660 src/flash/amd.c:673 src/flash/amd.c:686
#: src/flash/detectflash.c:117 src/flash/detectflash.c:149
msgid "AMD/Fujitsu Standard Command Set"
msgstr "AMD/Fujitsu Jeu standard de commandes"

#: src/flash/amd.c:661
msgid "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit"
msgstr "supportés: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit"

#: src/flash/amd.c:674
#, fuzzy
msgid "supported: AMD 29LV800B, S29GLxxxN; MX29LV640B, W19B320AT/B; 1x16 Bit"
msgstr "supportés: AMD 29LV800B; 1x16 Bit"

#: src/flash/amd.c:687
#, fuzzy
msgid ""
"supported: AMD 29LV160, AMD 29LV065D, AMD 29LV040B, S29GLxxxN, W19B320AT/B; "
"1x8 Bit"
msgstr "supportés: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit"

#: src/flash/amd_flash.c:263
#, fuzzy
msgid ""
"Chip: AMD Flash\n"
"\tPartNumber: "
msgstr ""
"Module: AMD Flash\n"
"\tManufacturier: "

#: src/flash/amd_flash.c:266
#, c-format
msgid "Unknown manufacturer (ID 0x%04x)"
msgstr "Manufacturier inconnu (ID 0x%04x)"

#: src/flash/amd_flash.c:274
msgid "5V Flash\n"
msgstr ""

#: src/flash/amd_flash.c:278
msgid "3V Flash\n"
msgstr ""

#: src/flash/amd_flash.c:425
#, fuzzy
msgid "AMD Standard Command Set"
msgstr "AMD/Fujitsu Jeu standard de commandes"

#: src/flash/amd_flash.c:426
#, fuzzy
msgid "supported: AMD 29LV040B, 29C040B, 1x8 Bit"
msgstr "supportés: AMD 29LV800B; 1x16 Bit"

#: src/flash/detectflash.c:75
msgid "bus driver"
msgstr ""

#: src/flash/detectflash.c:97
#, fuzzy
msgid "Flash not found"
msgstr "Flash non détecté!\n"

#: src/flash/detectflash.c:106
msgid "Query identification string:\n"
msgstr "Chaîne de requêtre d'identification:\n"

#: src/flash/detectflash.c:111 src/flash/detectflash.c:143
msgid "null"
msgstr "nul"

#: src/flash/detectflash.c:114 src/flash/detectflash.c:146
msgid "Intel/Sharp Extended Command Set"
msgstr "Jeu étendu de commandes Intel/Sharp"

#: src/flash/detectflash.c:120 src/flash/detectflash.c:152
#: src/flash/intel.c:575 src/flash/intel.c:588 src/flash/intel.c:601
msgid "Intel Standard Command Set"
msgstr "Jeu standard de commandes Intel"

#: src/flash/detectflash.c:123 src/flash/detectflash.c:155
msgid "AMD/Fujitsu Extended Command Set"
msgstr "Jeu étendu de commandes AMD/Fujitsu"

#: src/flash/detectflash.c:126 src/flash/detectflash.c:158
msgid "Mitsubishi Standard Command Set"
msgstr "Jeu standard de commandes Mitsubishi"

#: src/flash/detectflash.c:129 src/flash/detectflash.c:161
msgid "Mitsubishi Extended Command Set"
msgstr "Jeu étendu de commandes Mitsubishi"

#: src/flash/detectflash.c:132 src/flash/detectflash.c:164
msgid "Page Write Command Set"
msgstr "Jeu de commande d'écriture de page"

#: src/flash/detectflash.c:135 src/flash/detectflash.c:167
#: src/flash/detectflash.c:225
msgid "unknown!!!"
msgstr "inconnu!!!"

#: src/flash/detectflash.c:138
#, c-format
msgid ""
"\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n"
msgstr ""
"\tJeu de commandes Primary Algorithm et Code ID de contrôle d'interface: 0x"
"%04X (%s)\n"

#: src/flash/detectflash.c:170
#, c-format
msgid ""
"\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X "
"(%s)\n"
msgstr ""
"\tJeu alternatif de commandes Primary Algorithm et Code ID de contrôle "
"d'interface: 0x%04X (%s)\n"

#: src/flash/detectflash.c:174
msgid "Query system interface information:\n"
msgstr "Requête d'information d'interface système:\n"

#: src/flash/detectflash.c:175
#, c-format
msgid "\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n"
msgstr ""
"\tVcc logique Puissance minimum Écri/Efface ou Voltage d'écriture: %d mV\n"

#: src/flash/detectflash.c:177
#, c-format
msgid "\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n"
msgstr ""
"\tVcc logique Puissance maximum Écri/Efface ou Voltage d'écriture: %d mV\n"

#: src/flash/detectflash.c:179
#, c-format
msgid "\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n"
msgstr ""
"\tVpp [Programmation] puissance minimum Écriture/Efface voltage: %d mV\n"

#: src/flash/detectflash.c:181
#, c-format
msgid "\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n"
msgstr ""
"\tVpp [Programmation] puissance maximum Écriture/Efface voltage: %d mV\n"

#: src/flash/detectflash.c:183
#, c-format
msgid "\tTypical timeout per single byte/word program: %d us\n"
msgstr "\tDélai d'expiration typique par programme simple octet/mot: %d us\n"

#: src/flash/detectflash.c:185
#, c-format
msgid "\tTypical timeout for maximum-size multi-byte program: %d us\n"
msgstr ""
"\tDélai d'expiration typique pour la taille maximale par programme multi-"
"octets: %d us\n"

#: src/flash/detectflash.c:187
#, c-format
msgid "\tTypical timeout per individual block erase: %d ms\n"
msgstr ""
"\tDélai d'expiration typique par effacement individuel de blocs: %d ms\n"

#: src/flash/detectflash.c:189
#, c-format
msgid "\tTypical timeout for full chip erase: %d ms\n"
msgstr ""
"\tDélai d'expiration typique pour un effacement complet du module: %d ms\n"

#: src/flash/detectflash.c:191
#, c-format
msgid "\tMaximum timeout for byte/word program: %d us\n"
msgstr "\tDélai d'expiration maximal pour un programme octer/mot: %d us\n"

#: src/flash/detectflash.c:193
#, c-format
msgid "\tMaximum timeout for multi-byte program: %d us\n"
msgstr "\tDélai d'expiration maximum pour programme multi-octets: %d us\n"

#: src/flash/detectflash.c:195
#, c-format
msgid "\tMaximum timeout per individual block erase: %d ms\n"
msgstr ""
"\tDélai d'expiration maximum par effacement individuel de blocs: %d ms\n"

#: src/flash/detectflash.c:197
#, c-format
msgid "\tMaximum timeout for chip erase: %d ms\n"
msgstr ""
"\tDélai d'expiration maximum pour un effacement complet du module: %d ms\n"

#: src/flash/detectflash.c:201
msgid "Device geometry definition:\n"
msgstr "Définition de la géométrie du périphérique:\n"

#: src/flash/detectflash.c:202
#, c-format
msgid "\tDevice Size: %d B (%d KiB, %d MiB)\n"
msgstr "\tTaille du périphérique: %d O (%d KiB, %d MiB)\n"

#: src/flash/detectflash.c:210
msgid "x8"
msgstr "x8"

#: src/flash/detectflash.c:213
msgid "x16"
msgstr "x16"

#: src/flash/detectflash.c:216
msgid "x8/x16"
msgstr "x8/x16"

#: src/flash/detectflash.c:219
msgid "x32"
msgstr "x32"

#: src/flash/detectflash.c:222
msgid "x16/x32"
msgstr "x16/x32"

#: src/flash/detectflash.c:228
#, c-format
msgid "\tFlash Device Interface Code description: 0x%04X (%s)\n"
msgstr "\tDescription du code de l'interface du module: 0x%04X (%s)\n"

#: src/flash/detectflash.c:230
#, c-format
msgid "\tMaximum number of bytes in multi-byte program: %d\n"
msgstr "\tNombre maximum d'octets d'un programme multi-octest: %d\n"

#: src/flash/detectflash.c:232
#, c-format
msgid "\tNumber of Erase Block Regions within device: %d\n"
msgstr ""
"\tNumbre de régions de blocs d'effacement à l'intérieur du périphérique: %d\n"

#: src/flash/detectflash.c:234
msgid "\tErase Block Region Information:\n"
msgstr "\tInformation sur la région du bloc d'effacement:\n"

#: src/flash/detectflash.c:240
#, c-format
msgid "\t\tRegion %d:\n"
msgstr "\t\tRégion %d:\n"

#: src/flash/detectflash.c:241
#, c-format
msgid "\t\t\tErase Block Size: %d B (%d KiB)\n"
msgstr "\t\t\tTaille du bloc d'effacement: %d B (%d KiB)\n"

#: src/flash/detectflash.c:246
#, c-format
msgid "\t\t\tNumber of Erase Blocks: %d\n"
msgstr "\t\t\tNombre de blocs d'effacement: %d\n"

#: src/flash/detectflash.c:260
msgid "Required"
msgstr ""

#: src/flash/detectflash.c:260
msgid "Not required"
msgstr ""

#: src/flash/detectflash.c:263
msgid "Supported"
msgstr ""

#: src/flash/detectflash.c:263 src/flash/detectflash.c:277
#: src/flash/detectflash.c:288
#, fuzzy
msgid "Not supported"
msgstr "Flash non supporté!\n"

#: src/flash/detectflash.c:266
msgid "170-nm Floating Gate technology"
msgstr ""

#: src/flash/detectflash.c:267
msgid "230-nm MirrorBit(tm) technology"
msgstr ""

#: src/flash/detectflash.c:268
msgid "130-nm Floating Gate technology"
msgstr ""

#: src/flash/detectflash.c:269
msgid "110-nm MirrorBit(tm) technology"
msgstr ""

#: src/flash/detectflash.c:270
msgid "90-nm Floating Gate technology"
msgstr ""

#: src/flash/detectflash.c:271
msgid "90-nm MirrorBit(tm) technology"
msgstr ""

#: src/flash/detectflash.c:274
msgid "CS49"
msgstr ""

#: src/flash/detectflash.c:274
msgid "CS59"
msgstr ""

#: src/flash/detectflash.c:274
msgid "CS99"
msgstr ""

#: src/flash/detectflash.c:277
msgid "Read only"
msgstr ""

#: src/flash/detectflash.c:277
msgid "Read/write"
msgstr ""

#: src/flash/detectflash.c:280
msgid "29F040 mode"
msgstr ""

#: src/flash/detectflash.c:280
msgid "29F016 mode"
msgstr ""

#: src/flash/detectflash.c:280
msgid "29F400 mode"
msgstr ""

#: src/flash/detectflash.c:281
#, fuzzy
msgid "29LV800 mode"
msgstr "Am29LV800B"

#: src/flash/detectflash.c:282
msgid "29BDS640 mode (Software Command Locking)"
msgstr ""

#: src/flash/detectflash.c:283
msgid "29BDD160 mode (New Sector Protect)"
msgstr ""

#: src/flash/detectflash.c:284
msgid "29PDL128 mode (New Sector Protect + 29LV800)"
msgstr ""

#: src/flash/detectflash.c:285
msgid "Advanced Sector Protect"
msgstr ""

#: src/flash/detectflash.c:288
msgid "4 word Page"
msgstr ""

#: src/flash/detectflash.c:288
msgid "8 word Page"
msgstr ""

#: src/flash/detectflash.c:289
msgid "16 word Page"
msgstr ""

#: src/flash/detectflash.c:293
msgid "No boot"
msgstr ""

#: src/flash/detectflash.c:294
msgid "8x8kb sectors at top and bottom with WP control"
msgstr ""

#: src/flash/detectflash.c:295
msgid "Bottom boot device"
msgstr ""

#: src/flash/detectflash.c:295
msgid "Top boot device"
msgstr ""

#: src/flash/detectflash.c:296
msgid "Uniform bottom boot device"
msgstr ""

#: src/flash/detectflash.c:296
msgid "Uniform top boot device"
msgstr ""

#: src/flash/detectflash.c:298
msgid "Bad value"
msgstr ""

#: src/flash/detectflash.c:304
msgid "Primary Vendor-Specific Extended Query:\n"
msgstr ""

#: src/flash/detectflash.c:305
#, c-format
msgid "\tMajor version number: %c\n"
msgstr ""

#: src/flash/detectflash.c:307
#, c-format
msgid "\tMinor version number: %c\n"
msgstr ""

#: src/flash/detectflash.c:314 src/flash/detectflash.c:318
#, c-format
msgid "\tAddress Sensitive Unlock: %s\n"
msgstr ""

#: src/flash/detectflash.c:325 src/flash/detectflash.c:330
#: src/flash/detectflash.c:336 src/flash/detectflash.c:341
#, c-format
msgid "\tProcess Technology: %s\n"
msgstr ""

#: src/flash/detectflash.c:344
#, c-format
msgid "\tErase Suspend: %s\n"
msgstr ""

#: src/flash/detectflash.c:347
#, fuzzy
msgid "\tSector Protect: Not supported\n"
msgstr "Flash non supporté!\n"

#: src/flash/detectflash.c:349
#, c-format
msgid "\tSector Protect: %d sectors per group\n"
msgstr ""

#: src/flash/detectflash.c:353 src/flash/detectflash.c:357
#, c-format
msgid "\tSector Temporary Unprotect: %s\n"
msgstr ""

#: src/flash/detectflash.c:361 src/flash/detectflash.c:365
#, c-format
msgid "\tSector Protect/Unprotect Scheme: %s\n"
msgstr ""

#: src/flash/detectflash.c:368
#, fuzzy
msgid "\tSimultaneous Operation: Not supported\n"
msgstr "Flash non supporté!\n"

#: src/flash/detectflash.c:370
#, c-format
msgid "\tSimultaneous Operation: %d sectors\n"
msgstr ""

#: src/flash/detectflash.c:374 src/flash/detectflash.c:377
#, c-format
msgid "\tBurst Mode Type: %s\n"
msgstr ""

#: src/flash/detectflash.c:380 src/flash/detectflash.c:383
#, c-format
msgid "\tPage Mode Type: %s\n"
msgstr ""

#: src/flash/detectflash.c:389
#, c-format
msgid "\tACC (Acceleration) Supply Minimum: %d mV\n"
msgstr ""

#: src/flash/detectflash.c:391
#, c-format
msgid "\tACC (Acceleration) Supply Maximum: %d mV\n"
msgstr ""

#: src/flash/detectflash.c:395 src/flash/detectflash.c:398
#, c-format
msgid "\tTop/Bottom Sector Flag: %s\n"
msgstr ""

#: src/flash/detectflash.c:405 src/flash/detectflash.c:408
#, c-format
msgid "\tProgram Suspend: %s\n"
msgstr ""

#: src/flash/detectflash.c:415 src/flash/detectflash.c:418
#, c-format
msgid "\tUnlock Bypass: %s\n"
msgstr ""

#: src/flash/detectflash.c:419
#, c-format
msgid "\tSecSi Sector (Customer OTP Area) Size: %d bytes\n"
msgstr ""

#: src/flash/detectflash.c:421
#, c-format
msgid "\tEmbedded Hardware Reset Timeout Maximum: %d ns\n"
msgstr ""

#: src/flash/detectflash.c:423
#, c-format
msgid "\tNon-Embedded Hardware Reset Timeout Maximum: %d ns\n"
msgstr ""

#: src/flash/detectflash.c:425
#, c-format
msgid "\tErase Suspend Timeout Maximum: %d us\n"
msgstr ""

#: src/flash/detectflash.c:427
#, c-format
msgid "\tProgram Suspend Timeout Maximum: %d us\n"
msgstr ""

#: src/flash/detectflash.c:434
msgid "\tBank Organization:\n"
msgstr ""

#: src/flash/detectflash.c:436
#, c-format
msgid "\t\tBank%d: %d sectors\n"
msgstr ""

#: src/flash/flash.c:92
#, c-format
msgid "unknown flash - vendor id: %d (0x%04x)\n"
msgstr "flahs inconnu - identificateur du manufacturier: %d (0x%04x)\n"

#: src/flash/flash.c:96
#, fuzzy
msgid "Flash not supported"
msgstr "Flash non supporté!\n"

#: src/flash/flash.c:105
msgid "fread() was short"
msgstr ""

#: src/flash/flash.c:119 src/flash/flash.c:315 src/flash/flash.c:488
#: src/flash/flash.c:569
#, fuzzy
msgid "no flash driver found"
msgstr "aucun pilote de flahs repéré\n"

#: src/flash/flash.c:132
#, fuzzy
msgid "Invalid sync sequence"
msgstr "Séquence de synchro invalide!\n"

#: src/flash/flash.c:156
#, c-format
msgid "block %d unlocked\n"
msgstr "bloc %d déverrouillé\n"

#: src/flash/flash.c:159 src/flash/flash.c:366
#, c-format
msgid "erasing block %d: %d\n"
msgstr "effacement du bloc %d: %d\n"

#: src/flash/flash.c:164 src/flash/flash.c:338
msgid "program:\n"
msgstr "programme:\n"

#: src/flash/flash.c:174 src/flash/flash.c:226
#, fuzzy
msgid "premature end of file"
msgstr "ERREUR: fin prématurée du fichier\n"

#: src/flash/flash.c:178 src/flash/flash.c:230
#, fuzzy, c-format
msgid "record: start = 0x%08lX, len = 0x%08lX, checksum = 0x%08lX\n"
msgstr "enregistrement: début = 0x%08X, longueur = 0x%08X, checksum = 0x%08X\n"

#: src/flash/flash.c:184 src/flash/flash.c:236
#, fuzzy
msgid "Invalid record length"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/flash/flash.c:192 src/flash/flash.c:244 src/flash/flash.c:376
#: src/flash/flash.c:438
#, fuzzy, c-format
msgid "addr: 0x%08lX"
msgstr "adr: 0x%08X"

#: src/flash/flash.c:210 src/flash/flash.c:412
#, fuzzy
msgid "verify skipped\n"
msgstr "vérifier:\n"

#: src/flash/flash.c:215 src/flash/flash.c:417
msgid "verify:\n"
msgstr "vérifier:\n"

#: src/flash/flash.c:252
#, fuzzy, c-format
msgid "verify error: 0x%08lX vs. 0x%08lX at addr %08lX"
msgstr ""
"\n"
"ERREUR de vérification: 0x%08X vs. 0x%08X à l'adresse %08X\n"

#: src/flash/flash.c:331
#, c-format
msgid "malloc(%zd) failed"
msgstr ""

#: src/flash/flash.c:362
#, c-format
msgid ""
"\n"
"block %d unlocked\n"
msgstr ""
"\n"
"bloc %d déverrouillé\n"

#: src/flash/flash.c:405
#, fuzzy, c-format
msgid "addr: 0x%08lX\n"
msgstr "adr: 0x%08X"

#: src/flash/flash.c:457
#, fuzzy, c-format
msgid ""
"addr: 0x%08lX\n"
" verify error:\n"
"read: 0x%08lX\n"
"expected: 0x%08lX\n"
msgstr ""
"\n"
"ERREUR de vérification:\n"
"lu: 0x%08X\n"
"attendu: 0x%08X\n"

#: src/flash/flash.c:470
#, fuzzy, c-format
msgid ""
"addr: 0x%08lX\n"
"Done.\n"
msgstr "adr: 0x%08X"

#: src/flash/flash.c:497
#, c-format
msgid ""
"\n"
"Erasing %d Flash block%s from address 0x%lx\n"
msgstr ""

#: src/flash/flash.c:515
#, c-format
msgid "(%d%% Completed) FLASH Block %d : Unlocking ... "
msgstr ""

#: src/flash/flash.c:518
msgid "Erasing ... "
msgstr ""

#: src/flash/flash.c:526
#, c-format
msgid "(100%% Completed) FLASH Block %d : Unlocking ... Erasing ... Ok.\n"
msgstr ""

#: src/flash/flash.c:531 src/flash/flash.c:622
msgid "Ok."
msgstr ""

#: src/flash/flash.c:533 src/flash/flash.c:624
#, c-format
msgid "%78s"
msgstr ""

#: src/flash/flash.c:539 src/flash/flash.c:630
msgid "ERROR.\n"
msgstr ""

#: src/flash/flash.c:546
msgid ""
"\n"
"Erasing Completed.\n"
msgstr ""

#: src/flash/flash.c:548
msgid ""
"\n"
"Erasing (partially) Failed.\n"
msgstr ""

#: src/flash/flash.c:578
#, c-format
msgid ""
"\n"
"%s %d Flash block%s from address 0x%lx\n"
msgstr ""

#: src/flash/flash.c:600
#, c-format
msgid "(%d%% Completed) FLASH Block %d : %s ... "
msgstr ""

#: src/flash/flash.c:615
#, c-format
msgid "(100%% Completed) FLASH Block %d : %s ... Ok.\n"
msgstr ""

#: src/flash/flash.c:637
#, c-format
msgid ""
"\n"
"%s Completed.\n"
msgstr ""

#: src/flash/flash.c:640
#, c-format
msgid ""
"\n"
"%s (partially) Failed.\n"
msgstr ""

#: src/flash/intel.c:127 src/flash/intel.c:130 src/flash/intel.c:133
#, c-format
msgid "Manufacturer: %s\n"
msgstr "Manufacturier: %s\n"

#: src/flash/intel.c:136
#, fuzzy, c-format
msgid "Unknown manufacturer (0x%04lX)!\n"
msgstr "Manufacturier inconnu (0x%04X)!\n"

#: src/flash/intel.c:141
msgid "Chip: "
msgstr "Module: "

#: src/flash/intel.c:197
#, fuzzy, c-format
msgid "Unknown (0x%02lX)!\n"
msgstr "Inconnu (0x%02X)!\n"

#: src/flash/intel.c:258
#, fuzzy
msgid "invalid command seq"
msgstr "flash: séquence de commande invalide\n"

#: src/flash/intel.c:261
#, fuzzy
msgid "low vpen"
msgstr "flash: vpen bas\n"

#: src/flash/intel.c:264
#, fuzzy
msgid "block locked"
msgstr "bloc %d déverrouillé\n"

#: src/flash/intel.c:290
#, fuzzy
msgid "unknown error while unlocking block"
msgstr "flash: erreur inconnue lors du déverrouillage\n"

#: src/flash/intel.c:313
#, fuzzy
msgid "unknown error while locking block"
msgstr "flash: erreur inconnue lors du déverrouillage\n"

#: src/flash/intel.c:323
#, fuzzy
msgid "locking block failed"
msgstr "bloc %d déverrouillé\n"

#: src/flash/intel.c:347 src/flash/intel.c:407
#, fuzzy
msgid "unknown error while programming"
msgstr "flash: erreur inconnue lors de la programmation\n"

#: src/flash/intel.c:576
msgid "supported: 28Fxxxx, 2 x 16 bit"
msgstr "supportés: 28Fxxxx, 2 x 16 bit"

#: src/flash/intel.c:589
msgid "supported: 28Fxxxx, 1 x 16 bit"
msgstr "supportés: 28Fxxxx, 1 x 16 bit"

#: src/flash/intel.c:602
msgid "supported: 28Fxxxx, 1 x 8 bit"
msgstr "supportés: 28Fxxxx, 1 x 8 bit"

#: src/part/bsbit.c:50
#, fuzzy
msgid "missing Boundary Scan Register (BSR)"
msgstr "registre Boundary Scan Register (BSR) manquant\n"

#: src/part/bsbit.c:56
#, fuzzy
msgid "invalid boundary bit number"
msgstr "numéro de bit de limite invalide\n"

#: src/part/bsbit.c:61
#, fuzzy
msgid "duplicate bit declaration"
msgstr "déclaration double de bit\n"

#: src/part/bsbit.c:66
#, fuzzy
msgid "invalid control bit number"
msgstr "numéro de bit de contrôle invalide\n"

#: src/part/data_register.c:53
#, fuzzy
msgid "Data register name too long\n"
msgstr "AVERTISSEMENT: nom du registre de données trop long\n"

#: src/part/data_register.c:101
#, fuzzy, c-format
msgid "Data register '%s' already defined"
msgstr "registre de données '%s' est déjà défini\n"

#: src/part/instruction.c:51
#, fuzzy
msgid "Instruction name too long\n"
msgstr "AVERTISSEMENT: nom de l'instruction trop long\n"

#: src/part/part.c:238
#, fuzzy, c-format
msgid "signal '%s' cannot be set as output"
msgstr "signal '%s' ne peut être initialisé comme sortie\n"

#: src/part/part.c:253
#, fuzzy, c-format
msgid "signal '%s' cannot be set as input"
msgstr "signal '%s' ne peut être initialisé comme entrée\n"

#: src/part/part.c:287
#, fuzzy, c-format
msgid "signal '%s' is not input signal"
msgstr "signal '%s' n'est pas un signal d'entrée\n"

#: src/part/part.c:307
#, c-format
msgid "%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"
msgstr "%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/part/part.c:319 src/part/part.c:321
msgid "(none)"
msgstr "(aucun)"

#: src/part/part.c:335
#, fuzzy
msgid "instruction length is already set and used"
msgstr "la longueur d'instruction est déjà initialisée et utilisée\n"

#: src/part/part.c:362
#, fuzzy, c-format
msgid "Instruction '%s' already defined"
msgstr "Instruction '%s' est déjà définie\n"

#: src/part/part.c:370
#, fuzzy, c-format
msgid "unknown data register '%s'"
msgstr "registre de données inconnu '%s'\n"

#: src/svf/svf.c:472
#, c-format
msgid "Error %s: mismatch at position %d for TDO\n"
msgstr ""

#: src/svf/svf.c:550
#, c-format
msgid "calloc(%zd,%zd) fails"
msgstr ""

#: src/svf/svf.c:624 src/svf/svf.c:1081
#, c-format
msgid "command %s not implemented\n"
msgstr ""

#: src/svf/svf.c:661
#, c-format
msgid "Error %s: only TCK is supported for RUNTEST"
msgstr ""

#: src/svf/svf.c:668
#, c-format
msgid "Error %s: maximum time must be larger or equal to minimum time"
msgstr ""

#: src/svf/svf.c:676
msgid "maximum time for RUNTEST not guaranteed.\n"
msgstr ""

#: src/svf/svf.c:677
msgid " This message is only displayed once.\n"
msgstr ""

#: src/svf/svf.c:710
#, c-format
msgid "Error %s: Maximum cable clock frequency required for RUNTEST"
msgstr ""

#: src/svf/svf.c:713
msgid "  Set the cable frequency with 'FREQUENCY <Hz>'.\n"
msgstr ""

#: src/svf/svf.c:878
#, c-format
msgid "Error %s: first %s command after length change must have a TDI value.\n"
msgstr ""

#: src/svf/svf.c:906
#, c-format
msgid "Error %s: SIR command length inconsistent.\n"
msgstr ""

#: src/svf/svf.c:910
#, c-format
msgid " in input file between line %d col %d and line %d col %d\n"
msgstr ""

#: src/svf/svf.c:1011
#, c-format
msgid "Error %s: no further TRST command allowed after mode ABSENT"
msgstr ""

#: src/svf/svf.c:1034
#, c-format
msgid "Error %s: TRST ABSENT must not be issued after a STATE command"
msgstr ""

#: src/svf/svf.c:1042
#, c-format
msgid "Error %s: TRST ABSENT must not be issued after an SIR or SDR command"
msgstr ""

#: src/svf/svf.c:1052
#, c-format
msgid "unimplemented mode '%s' for TRST\n"
msgstr ""

#: src/svf/svf.c:1145
#, fuzzy, c-format
msgid "%s: no JTAG chain available"
msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#: src/svf/svf.c:1152
#, c-format
msgid "%s: chain without any parts"
msgstr ""

#: src/svf/svf.c:1168
#, c-format
msgid "%s: could not establish SDR register"
msgstr ""

#: src/svf/svf.c:1208
#, c-format
msgid "%s: could not establish SIR instruction"
msgstr ""

#: src/svf/svf.c:1245
msgid ""
"Mismatches occurred between scanned device output and expected TDO values.\n"
msgstr ""

#: src/svf/svf.c:1248
msgid "Scanned device output matched expected TDO values.\n"
msgstr ""

#: src/svf/svf_flex.l:404
#, c-format
msgid "Parsing %6d/%d (%3.0d%%)"
msgstr ""

#: src/svf/svf_flex.l:424 src/tap/cable/ft2232.c:2212
#: src/tap/cable/generic_parport.c:89 src/tap/cable/generic_usbconn.c:156
#: src/tap/cable/jim.c:71 src/tap/cable/ts7800.c:170
#: src/tap/cable/usbblaster.c:79 src/tap/cable/vision_ep9307.c:214
#: src/tap/cable/wiggler.c:226
#, c-format
msgid "malloc(%zd) fails"
msgstr ""

#: src/tap/cable/arcom.c:143
msgid "Arcom JTAG Cable"
msgstr "Cable JTAG Arcom"

#: src/tap/cable/byteblaster.c:182
msgid ""
"Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable"
msgstr ""
"Cable du port parallèle de chargement Altera ByteBlaster/ByteBlaster II/"
"ByteBlasterMV"

#: src/tap/cable.c:95 src/tap/usbconn/libusb.c:156
#, c-format
msgid "malloc(%zd)/malloc(%zd) fails"
msgstr ""

#: src/tap/cable.c:149
#, c-format
msgid "(Resized JTAG activity queue to hold max %d items)\n"
msgstr ""

#: src/tap/cable.c:336 src/tap/cable.c:397
#, c-format
msgid "Internal error: Got wrong type of result from queue (%d? %p.%d)\n"
msgstr ""

#: src/tap/cable.c:404
#, c-format
msgid "Internal error: Got wrong signal's value from queue (%d? %p.%d)\n"
msgstr ""

#: src/tap/cable.c:461
#, c-format
msgid "Internal error: Got wrong type of result from queue (#%d %p.%d)\n"
msgstr ""

#: src/tap/cable.c:468
msgid "Internal error: Wanted transfer result but none was queued\n"
msgstr ""

#: src/tap/cable/dlc5.c:137
msgid "Xilinx DLC5 JTAG Parallel Cable III"
msgstr "Cable parallèle JTAG Xilinx DLC5 III"

#: src/tap/cable/ea253.c:143
msgid "ETC EA253 JTAG Cable"
msgstr "Cable JATB ETC EA253"

#: src/tap/cable/ei012.c:145
msgid "ETC EI012 JTAG Cable"
msgstr "Cable JTAG ETC EI012"

#: src/tap/cable/ft2232.c:317
#, c-format
msgid "Warning: Setting lowest supported frequency for FT2232%s: %d\n"
msgstr ""

#: src/tap/cable/ft2232.c:895
msgid "Please power on the TARGET board and connect VCC signal"
msgstr ""

#: src/tap/cable/ft2232.c:1026
msgid "Vref not detected. Please power on Milkymist One"
msgstr ""

#: src/tap/cable/ft2232.c:2258
msgid "Generic FTDI FT2232 Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2278
msgid "Olimex ARM-USB-OCD[-TINY] (FT2232) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2299
msgid "Olimex ARM-USB-TINY-H (FT2232H) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2320
msgid "Analog Devices Blackfin gnICE (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2340
msgid "Analog Devices Blackfin gnICE+ (FT2232H) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2360
msgid "Amontec JTAGkey (FT2232) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2380
msgid "OOCDLink-s (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2400
msgid "Turtelizer 2 Rev. B (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2420
msgid "USB<=>JTAG&RS232 (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2440
msgid "USB to JTAG Interface (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2460
msgid "Xverve DT-USB-ST Signalyzer Tool (FT2232) Cable (EXPERIMENTAL)"
msgstr ""

#: src/tap/cable/ft2232.c:2480
msgid "TinCanTools Flyswatter (FT2232) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2500
msgid "KrisTech usbScarabeus2 (FT2232) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2520
msgid "KrisTech KT-LINK (FT2232H based) Cable"
msgstr ""

#: src/tap/cable/ft2232.c:2540
msgid "Milkymist JTAG/serial (FT2232) Cable"
msgstr ""

#: src/tap/cable/generic.c:104
msgid "No space in cable activity results queue"
msgstr ""

#: src/tap/cable/generic.c:423
msgid "calibration error, wall clock is not monotonically increasing\n"
msgstr ""

#: src/tap/cable/generic_parport.c:62
msgid "extra arguments"
msgstr ""

#: src/tap/cable/generic_parport.c:72
#, fuzzy, c-format
msgid "Unknown port type: %s"
msgstr "registre de données inconnu '%s'\n"

#: src/tap/cable/generic_parport.c:120
#, c-format
msgid ""
"Usage: cable %s parallel PORTADDR\n"
"   or: cable %s ppdev PPDEV\n"
"   or: cable %s ppi PPIDEV\n"
"\n"
"PORTADDR   parallel port address (e.g. 0x378)\n"
"PPDEV      ppdev device (e.g. /dev/parport0)\n"
"PPIDEF     ppi device (e.g. /dev/ppi0)\n"
"\n"
msgstr ""

#: src/tap/cable/generic_usbconn.c:142
msgid "Couldn't connect to suitable USB device.\n"
msgstr ""

#: src/tap/cable/generic_usbconn.c:198
#, fuzzy, c-format
msgid "Unable to locate cable %s"
msgstr "Incapable de créer le fichier `%s'!\n"

#: src/tap/cable/generic_usbconn.c:203
#, c-format
msgid ""
"Usage: cable %s %s %s\n"
"\n"
"%s%s\n"
"Default:   vid=%x pid=%x driver=%s\n"
"\n"
msgstr ""

#: src/tap/cable/generic_usbconn.c:240
#, c-format
msgid "Found USB cable: %s\n"
msgstr ""

#: src/tap/cable/gpio.c:75
#, c-format
msgid "%s: cannot open to (un)export GPIO %u\n"
msgstr ""

#: src/tap/cable/gpio.c:98
#, fuzzy, c-format
msgid "%s: cannot open to set direction\n"
msgstr "ne peut ouvrir %s\n"

#: src/tap/cable/gpio.c:107
#, c-format
msgid "Error setting direction gpio %u %s %d\n"
msgstr ""

#: src/tap/cable/gpio.c:123
msgid "Error setting value gpio\n"
msgstr ""

#: src/tap/cable/gpio.c:139
#, c-format
msgid "Error getting value of gpio %u\n"
msgstr ""

#: src/tap/cable/gpio.c:161
#, c-format
msgid "gpio[%d] %u cannot be exported\n"
msgstr ""

#: src/tap/cable/gpio.c:171
#, fuzzy, c-format
msgid "%s: cannot open gpio[%d] %u\n"
msgstr "ne peut ouvrir %s\n"

#: src/tap/cable/gpio.c:199
#, c-format
msgid ""
"Usage: cable %s tdi=<gpio_tdi> tdo=<gpio_tdo> tck=<gpio_tck> tms=<gpio_tms>\n"
"\n"
msgstr ""

#: src/tap/cable/gpio.c:213
#, c-format
msgid "calloc(%zd) fails"
msgstr ""

#: src/tap/cable/gpio.c:247
#, fuzzy
msgid "Initializing GPIO JTAG Chain\n"
msgstr "Initialisation de %s sur le port ppdev %s\n"

#: src/tap/cable/gpio.c:258
msgid "missing required gpios\n"
msgstr ""

#: src/tap/cable/gpio.c:383
#, fuzzy
msgid "GPIO JTAG Chain"
msgstr "sélectionner le cable JTAG"

#: src/tap/cable/jim.c:55
msgid "too many arguments"
msgstr ""

#: src/tap/cable/jim.c:59
msgid "JTAG target simulator JIM - work in progress!\n"
msgstr ""

#: src/tap/cable/jim.c:156
#, c-format
msgid "Usage: cable %s\n"
msgstr ""

#: src/tap/cable/jim.c:161
msgid "JTAG target simulator JIM"
msgstr ""

#: src/tap/cable/jlink.c:600
msgid "Segger/IAR J-Link, Atmel SAM-ICE and others."
msgstr ""

#: src/tap/cable/keithkoep.c:153
msgid "Keith & Koep JTAG cable"
msgstr "Cable JTAG Keith & Koep"

#: src/tap/cable/lattice.c:145
#, fuzzy
msgid "Lattice Parallel Port JTAG Cable"
msgstr "Cable JTAG Macraigor Wiggler"

#: src/tap/cable/mpcbdm.c:152
msgid "Mpcbdm JTAG cable"
msgstr "Cable JTAG Mpcbdm"

#: src/tap/cable/triton.c:155
msgid "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable"
msgstr "Cable JTAG Ka-Ro TRITON Starterkit II (PXA255/250)"

#: src/tap/cable/ts7800.c:89 src/tap/cable/vision_ep9307.c:95
#, fuzzy
msgid "unable to open /dev/mem"
msgstr "ERREUR: mémoire épuisée!\n"

#: src/tap/cable/ts7800.c:102 src/tap/cable/vision_ep9307.c:138
#, fuzzy
msgid "unable to mmap the GPIO registers"
msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#: src/tap/cable/ts7800.c:127 src/tap/cable/vision_ep9307.c:164
#, fuzzy
msgid "unable to munmap the GPIO registers"
msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#: src/tap/cable/ts7800.c:160 src/tap/cable/vision_ep9307.c:204
msgid "This cable type does not accept parameters"
msgstr ""

#: src/tap/cable/ts7800.c:165
msgid "Initializing TS-7800 Built-in JTAG Chain\n"
msgstr ""

#: src/tap/cable/ts7800.c:292 src/tap/cable/vision_ep9307.c:342
#, c-format
msgid ""
"Usage: cable %s\n"
"\n"
msgstr ""

#: src/tap/cable/ts7800.c:297
msgid "TS-7800 Built-in JTAG Chain"
msgstr ""

#: src/tap/cable/usbblaster.c:103
#, c-format
msgid "USB-Blaster frequency is fixed to %ld Hz\n"
msgstr ""

#: src/tap/cable/usbblaster.c:500
msgid "Altera USB-Blaster Cable"
msgstr ""

#: src/tap/cable/vision_ep9307.c:107
msgid "unable to mmap the System Control registers"
msgstr ""

#: src/tap/cable/vision_ep9307.c:127
msgid "unable to munmap the System Controller registers"
msgstr ""

#: src/tap/cable/vision_ep9307.c:209
msgid "Initializing Vision EP9307 SoM GPIO JTAG Cable\n"
msgstr ""

#: src/tap/cable/vision_ep9307.c:347
msgid "Vision EP9307 SoM GPIO JTAG Cable"
msgstr ""

#: src/tap/cable/wiggler2.c:164
msgid "Modified (with CPU Reset) WIGGLER JTAG Cable"
msgstr ""

#: src/tap/cable/wiggler.c:248
msgid "Pin mapping failed\n"
msgstr ""

#: src/tap/cable/wiggler.c:393
#, c-format
msgid ""
"Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n"
"   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n"
"   or: cable %s ppi PPIDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n"
"\n"
"PORTADDR   parallel port address (e.g. 0x378)\n"
"PPDEV      ppdev device (e.g. /dev/parport0)\n"
"PPIDEF     ppi device (e.g. /dev/ppi0)\n"
"TDO, ...   parallel port bit number, prepend '#' for inversion\n"
"           default is '%s'\n"
"\n"
msgstr ""

#: src/tap/cable/wiggler.c:420
msgid "Macraigor Wiggler JTAG Cable"
msgstr "Cable JTAG Macraigor Wiggler"

#: src/tap/cable/wiggler.c:439
#, fuzzy
msgid "Excelpoint IGLOO JTAG Cable"
msgstr "Cable JTAG Arcom"

#: src/tap/cable/xpc.c:691
msgid "Xilinx Platform Cable USB internal chain"
msgstr ""

#: src/tap/cable/xpc.c:711
msgid "Xilinx Platform Cable USB external chain"
msgstr ""

#: src/tap/chain.c:266 src/tap/chain.c:334
#, fuzzy, c-format
msgid "Part %d without active instruction"
msgstr "%s(%d) pièce %d sans instruction active\n"

#: src/tap/chain.c:340
#, fuzzy, c-format
msgid "Part %d without data register"
msgstr "%s(%d) pièce %d sans registre de données\n"

#: src/tap/chain.c:405
#, fuzzy
msgid "Run \"detect\" first"
msgstr "Eéxcuer \"détecter\" d'abord.\n"

#: src/tap/chain.c:411
#, c-format
msgid "active part no %d exceeds chain length %d"
msgstr ""

#: src/tap/detect.c:66
#, fuzzy, c-format
msgid "Unable to open file '%s'\n"
msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#: src/tap/detect.c:202
#, c-format
msgid "IR length: %d\n"
msgstr "longueur IR: %d\n"

#: src/tap/detect.c:220
msgid "Unable to detect JTAG chain length\n"
msgstr "Incapable de détecter la longueur de la chaîne JTAG\n"

#: src/tap/detect.c:223
#, c-format
msgid "Chain length: %d\n"
msgstr "Longueur de la chaîne: %d\n"

#: src/tap/detect.c:293
#, fuzzy, c-format
msgid "Device Id: %s (0x%0*<PRIX64>)\n"
msgstr "Identificateur du périphérique: %s\n"

#: src/tap/detect.c:302
msgid "Device Id: not supported (bit 0 was not a 1)\n"
msgstr ""

#: src/tap/detect.c:336
#, fuzzy
msgid "Unknown manufacturer!"
msgstr "  Manufacturier inconnu!\n"

#: src/tap/detect.c:348
#, fuzzy
msgid "Manufacturer too long\n"
msgstr "AVERTISSEMENT: nom du manufacturier trop long\n"

#: src/tap/detect.c:366
#, fuzzy
msgid "Unknown part!"
msgstr "  Pièce inconnue!\n"

#: src/tap/detect.c:372
#, fuzzy, c-format
msgid "  Part(%d):      %s (0x%03<PRIX64>)\n"
msgstr "  Pièce:         %s\n"

#: src/tap/detect.c:378
#, fuzzy
msgid "Part too long\n"
msgstr "AVERTISSEMENT: nom de pièce trop long\n"

#: src/tap/detect.c:396
#, fuzzy
msgid "Unknown stepping!"
msgstr "  Pas inconnu!\n"

#: src/tap/detect.c:403
#, c-format
msgid "  Stepping:     %s\n"
msgstr "  Pas     :     %s\n"

#: src/tap/detect.c:406
#, fuzzy
msgid "Stepping too long\n"
msgstr "AVERTISSEMENT: pas trop long\n"

#: src/tap/detect.c:456
msgid "Error: Unable to detect JTAG chain end!\n"
msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#: src/tap/detect.c:508
msgid "Error: could not set BR register"
msgstr ""

#: src/tap/detect.c:529
msgid "Error: could not set BYPASS instruction"
msgstr ""

#: src/tap/discovery.c:120
#, c-format
msgid "TDO seems to be stuck at %d\n"
msgstr ""

#: src/tap/discovery.c:136
msgid "Detecting IR length ... "
msgstr "Détection de la longuer IR..."

#: src/tap/discovery.c:142 src/tap/discovery.c:178
#, c-format
msgid "%d\n"
msgstr "%d\n"

#: src/tap/discovery.c:147
msgid "Error: Invalid IR length!\n"
msgstr "ERREUR: longueur IR invalide!\n"

#: src/tap/discovery.c:171
#, c-format
msgid "Detecting DR length for IR %s ... "
msgstr "Détection de la longeur DR de IR %s..."

#: src/tap/parport/direct.c:146
msgid "Couldn't load InpOut32.dll; maybe not installed?"
msgstr ""

#: src/tap/parport/direct.c:212
#, fuzzy
msgid "Invalid port address"
msgstr "Adresse de port invalide!\n"

#: src/tap/parport/direct.c:227
#, c-format
msgid "Disconnecting %s from parallel port at 0x%x\n"
msgstr "Déconnexion de %s du port parallèle à 0x%x\n"

#: src/tap/parport/direct.c:234
#, fuzzy, c-format
msgid "Initializing parallel port at 0x%x\n"
msgstr "Initialisation de %s sur le port parallèle à 0x%x\n"

#: src/tap/parport/ppdev.c:119
#, c-format
msgid "Disconnecting %s from ppdev port %s\n"
msgstr "Déconnexion de %s du port ppdev %s\n"

#: src/tap/parport/ppdev.c:125
#, fuzzy, c-format
msgid "Initializing ppdev port %s\n"
msgstr "Initialisation de %s sur le port ppdev %s\n"

#: src/tap/parport/ppdev.c:142
#, fuzzy, c-format
msgid "Could not open port %s"
msgstr "ne peut ouvrir %s\n"

#: src/tap/parport/ppdev.c:149
msgid "Could not claim ppdev device"
msgstr ""

#: src/tap/parport/ppi.c:117
#, fuzzy, c-format
msgid "Disconnecting %s from ppi port %s\n"
msgstr "Déconnexion de %s du port ppdev %s\n"

#: src/tap/parport/ppi.c:123
#, fuzzy, c-format
msgid "Initializing ppi port %s\n"
msgstr "Initialisation de %s sur le port ppdev %s\n"

#: src/tap/register.c:160
#, c-format
msgid "invalid hex string '%s'"
msgstr ""

#: src/tap/register.c:174
#, c-format
msgid "bit patterns should be 0s and 1s, not '%s'"
msgstr ""

#: src/tap/register.c:181
#, c-format
msgid "register length %d mismatch: %zd"
msgstr ""

#: src/tap/register.c:208
#, c-format
msgid "register %d:%d will not fit in %d bits"
msgstr ""

#: src/tap/tap.c:87 src/tap/tap.c:160 src/tap/tap.c:173
#, c-format
msgid "%s: Invalid state: %2X\n"
msgstr "%s: état invalide: %2X\n"

#: src/tap/usbconn/libftd2xx.c:127
#, c-format
msgid "FT_Write() failed: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:135 src/tap/usbconn/libftdi.c:93
msgid "Written fewer bytes than requested"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:155 src/tap/usbconn/libftdi.c:114
msgid "Receive buffer does not exist"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:162 src/tap/usbconn/libftd2xx.c:224
#, c-format
msgid "Error from FT_Read(): %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:167 src/tap/usbconn/libftdi.c:156
#, c-format
msgid "%s(): Received fewer bytes than requested.\n"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:291 src/tap/usbconn/libftdi.c:266
msgid "Send buffer does not exist"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:356
msgid "Connected to libftd2xx driver.\n"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:433 src/tap/usbconn/libftd2xx.c:480
#: src/tap/usbconn/libftd2xx.c:515 src/tap/usbconn/libftd2xx.c:542
#, c-format
msgid "Can't reset device: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:437 src/tap/usbconn/libftd2xx.c:519
#: src/tap/usbconn/libftd2xx.c:546
#, c-format
msgid "Can't purge RX buffer: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:442
#, c-format
msgid "Can't set latency timer: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:447
#, c-format
msgid "Can't set baudrate: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:484
#, c-format
msgid "s(): Can't purge RX buffer: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:491
#, c-format
msgid "Can't set USB parameters: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:496
#, c-format
msgid "Can't set special characters: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:504
#, c-format
msgid "Can't set target latency timer: %s"
msgstr ""

#: src/tap/usbconn/libftd2xx.c:510
#, c-format
msgid "Can't set MPSSE bitmode: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:87
#, c-format
msgid "ftdi_write_data() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:123
#, c-format
msgid "Error from ftdi_read_data_submit(): %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:135
msgid "Written fewer bytes than requested."
msgstr ""

#: src/tap/usbconn/libftdi.c:150 src/tap/usbconn/libftdi.c:207
#, c-format
msgid "Error from ftdi_read_data(): %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:336
msgid "Connected to libftdi driver.\n"
msgstr ""

#: src/tap/usbconn/libftdi.c:370
#, c-format
msgid "%s(): ftdi_set_interface() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:388
#, c-format
msgid "%s(): ftdi_usb_open_desc() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:390
#, c-format
msgid "ftdi_usb_open_desc() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:418
#, c-format
msgid "ftdi_usb_purge_buffers() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:422 src/tap/usbconn/libftdi.c:443
#, c-format
msgid "ftdi_read_data() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:432
#, c-format
msgid "ftdi_usb_purge_rx_buffer() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:439
#, c-format
msgid "ftdi_usb_purge_tx_buffer() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:460
#, c-format
msgid "ftdi_poll_status() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:465 src/tap/usbconn/libftdi.c:581
#: src/tap/usbconn/libftdi.c:603
#, c-format
msgid "ftdi_usb_reset() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:491 src/tap/usbconn/libftdi.c:571
#, c-format
msgid "ftdi_set_latency_timer() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:508
#, c-format
msgid "ftdi_set_baudrate() failed: %s"
msgstr ""

#: src/tap/usbconn/libftdi.c:576
#, c-format
msgid "ftdi_set_bitmode() failed: %s"
msgstr ""

#, fuzzy
#~ msgid ""
#~ "Blackfin BF533 EZKit compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF533 compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF537 Stamp board bus driver via BSR"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF537 EZ-KIT board bus driver via BSR"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF527 EZ-KIT board bus driver via BSR"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF538F EZ-KIT board bus driver"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Blackfin BF526 EZ-KIT board bus driver"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid ""
#~ "Blackfin BF548 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid ""
#~ "Blackfin BF561 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "pilote de bus compatible Hitachi SH7751R via BSR (JTAG no de pièce %d)\n"

#, fuzzy
#~ msgid "Unknown cable type: '%s'"
#~ msgstr "Cable inconnue: %s\n"

#~ msgid "%-13s %s\n"
#~ msgstr "%-13s %s\n"

#~ msgid "%s\n"
#~ msgstr "%s\n"

#~ msgid "Endianness for external files: little\n"
#~ msgstr ""
#~ "système de poids fort/faible des fichiers externes: petit (little "
#~ "endian)\n"

#~ msgid ""
#~ "%s\n"
#~ "     %s\n"
#~ msgstr ""
#~ "%s\n"
#~ "     %s\n"

#~ msgid "(no description available)"
#~ msgstr "(pas de description disponible)"

#, fuzzy
#~ msgid "Unknown bus: %s"
#~ msgstr "bus inconnu: %s\n"

#~ msgid "%-10s %s\n"
#~ msgstr "%-10s %s\n"

#, fuzzy
#~ msgid ""
#~ "Usage: %s SIGNAL 0/1\n"
#~ "Test signal state from output BSR (Boundary Scan Register).\n"
#~ "\n"
#~ "SIGNAL        signal name (from JTAG declaration file)\n"
#~ msgstr ""
#~ "Usage: %s SIGNAL\n"
#~ "Obtenir l'état du signal de la sortie BSR (Boundary Scan Register).\n"
#~ "\n"
#~ "SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"

#~ msgid "  Manufacturer: %s\n"
#~ msgstr "  Manufacturier: %s\n"

#, fuzzy
#~ msgid "Out of memory, %s line %i\n"
#~ msgstr "Mémoire épuisée\n"

#, fuzzy
#~ msgid "No JTAG chain available\n"
#~ msgstr "(pas de description disponible)"

#, fuzzy
#~ msgid "Unable to open BSDL file '%s'\n"
#~ msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#, fuzzy
#~ msgid "Cannot open file %s or %s.\n"
#~ msgstr "ne peut ouvrir %s\n"

#~ msgid "out of memory\n"
#~ msgstr "mémoire épuisée\n"

#, fuzzy
#~ msgid "signal '%s' is not found\n"
#~ msgstr "signal '%s' non repéré\n"

#~ msgid "Error: Bus width detection failed\n"
#~ msgstr "ERREUR: détection de la largeur de bus a échoué\n"

#~ msgid "Error: Invalid bus width (MD3 = MD4 = 0)!\n"
#~ msgstr "ERREUR: largeur de bus invalide (MD3 = MD4 = 0)!\n"

#, fuzzy
#~ msgid "Addr: 0x%08X\n"
#~ msgstr "adr: 0x%08X\n"

#~ msgid "%s: no active part\n"
#~ msgstr "%s: aucune pièce active\n"

#~ msgid "Error: Cable connection failed!\n"
#~ msgstr "Error: échec de la connexion par cable!\n"

#~ msgid "Error: Cable initialization failed!\n"
#~ msgstr "Error: échec de l'initialisation par cable!\n"

#~ msgid "Error: Cable not configured. Please use '%s' command first!\n"
#~ msgstr ""
#~ "ERREUR: cable non configuré. SVP utiliser la commande '%s' d'abord!\n"

#~ msgid "%s: syntax error!\n"
#~ msgstr "%s: erreur de syntaxe!\n"

#, fuzzy
#~ msgid "Unable to open file `%s go=%d'!\n"
#~ msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#, fuzzy
#~ msgid "bus alloc/attach failed!\n"
#~ msgstr "initialisation du bus a échoué!\n"

#~ msgid "bus initialization failed!\n"
#~ msgstr "initialisation du bus a échoué!\n"

#~ msgid ""
#~ "\n"
#~ "flash error\n"
#~ msgstr ""
#~ "\n"
#~ "erreur flash\n"

#~ msgid "Out of memory!\n"
#~ msgstr "Mémoire épuisée!\n"

#~ msgid "flash: block locked\n"
#~ msgstr "flash: bloc verrouillé\n"

#, fuzzy
#~ msgid "out of memory"
#~ msgstr "mémoire épuisée\n"

#, fuzzy
#~ msgid "Initialization failed.\n"
#~ msgstr "initialisation du bus a échoué!\n"

#, fuzzy
#~ msgid "%s(%d) Out of memory\n"
#~ msgstr "%s(%d) Mémoire épuisée.\n"

#, fuzzy
#~ msgid "Error: Unable to allocate space for parts!\n"
#~ msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#, fuzzy
#~ msgid "Error: Unable to allocate space for a part!\n"
#~ msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#~ msgid "Error: Out of memory!\n"
#~ msgstr "ERREUR: mémoire épuisée!\n"

#~ msgid "Syntax error!\n"
#~ msgstr "ERREUR de syntaxe!\n"

#~ msgid "%s(%d) Out of memory.\n"
#~ msgstr "%s(%d) Mémoire épuisée.\n"

#~ msgid "supported: AMD 29LV800B; 1x16 Bit"
#~ msgstr "supportés: AMD 29LV800B; 1x16 Bit"

#, fuzzy
#~ msgid ""
#~ "Blackfin BF537 Stamp compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid ""
#~ "Blackfin BF537 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid ""
#~ "Blackfin BF527 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#~ msgid "Intel PXA2x0 compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#, fuzzy
#~ msgid "Intel PXA27x compatible bus driver via BSR (JTAG part No. %d)\n"
#~ msgstr ""
#~ "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#~ msgid "AMD"
#~ msgstr "AMD"

#, fuzzy
#~ msgid "Am29LV040B"
#~ msgstr "Am29LV800B"

#~ msgid "Am29LV640D/Am29LV641D/Am29LV642D"
#~ msgstr "Am29LV640D/Am29LV641D/Am29LV642D"

#~ msgid "Am29LV800B"
#~ msgstr "Am29LV800B"

#, fuzzy
#~ msgid "MX29LV160B"
#~ msgstr "Am29LV800B"

#, fuzzy
#~ msgid "AM29LV160DB"
#~ msgstr "Am29LV800B"

#, fuzzy
#~ msgid "Am29LV065D"
#~ msgstr "Am29LV800B"

#, fuzzy
#~ msgid "Am29C040B\t-\t"
#~ msgstr "Am29LV800B"

#, fuzzy
#~ msgid "Am29LV040B\t-\t"
#~ msgstr "Am29LV800B"

#~ msgid "Error during file read.\n"
#~ msgstr "ERREUR durant la lecture du fichier.\n"

#, fuzzy
#~ msgid "Disconnecting %s\n"
#~ msgstr "Déconnexion de %s du port ppdev %s\n"

#, fuzzy
#~ msgid "Disconnecting %s from FTDI device %s\n"
#~ msgstr "Déconnexion de %s du port ppdev %s\n"

#, fuzzy
#~ msgid "Initializing %s on FTDI device %s\n"
#~ msgstr "Initialisation de %s sur le port ppdev %s\n"

#, fuzzy
#~ msgid "Disconnecting %s, device %s\n"
#~ msgstr "Déconnexion de %s du port ppdev %s\n"

#, fuzzy
#~ msgid "Initializing %s, device %s\n"
#~ msgstr "Initialisation de %s sur le port ppdev %s\n"

#, fuzzy
#~ msgid "Initializing device %s\n"
#~ msgstr "Initialisation de %s sur le port ppdev %s\n"

#~ msgid ""
#~ "Usage: %s FILENAME\n"
#~ "Run command sequence from external FILENAME from the repository.\n"
#~ "\n"
#~ "FILENAME      Name of the file with commands\n"
#~ msgstr ""
#~ "Usage: %s FICHIER\n"
#~ "Exécuter une séquence de commandes à partir du FICHIER du dépôt externe.\n"
#~ "\n"
#~ "FICHIER       nom du fichier contenant les commandes\n"

#~ msgid "supported: AMD 29LV160; 1x8 Bit"
#~ msgstr "supportés: AMD 29LV160; 1x8 Bit"

#~ msgid "Unknown connection type: %s\n"
#~ msgstr "Type de connexion inconnue: %s\n"

#~ msgid ""
#~ "Usage: %s PORTADDR CABLE\n"
#~ "Usage: %s DEV CABLE\n"
#~ "Select JTAG cable connected to parallel port.\n"
#~ "\n"
#~ "PORTADDR   parallel port address (e.g. 0x378)\n"
#~ "CABLE      cable type\n"
#~ "DEV        ppdev device (e.g. /dev/parport0)\n"
#~ "\n"
#~ "List of supported cables:\n"
#~ "%-13s No cable connected\n"
#~ msgstr ""
#~ "Usage: %s ADDR_PORT CABLE\n"
#~ "Usage: %s PÉRIPHÉRIQUE CABLE\n"
#~ "Sélectionner le cable JTAG connecté au port parallèle.\n"
#~ "\n"
#~ "ADDR_PORT  adresse du port parallèle (i.e. 0x378)\n"
#~ "CABLE      type de cable\n"
#~ "PÉR        PÉRiphérique (i.e. /dev/parport0)\n"
#~ "\n"
#~ "Lists des cables supportés:\n"
#~ "%-13s Aucun cable connecté\n"

#~ msgid "Note: Supported configuration is 2 x 16 bit or 1 x 16 bit only\n"
#~ msgstr ""
#~ "Note: configuration supportés sont 2 x 16 bits ou 1 x 16 bits seulement\n"

#~ msgid "Changed cable to 'none'\n"
#~ msgstr "Cable changé pour 'aucun'\n"
