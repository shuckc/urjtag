# Messages français pour GNU concernant jtag.
# Copyright © 2004 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, traducteur depuis/since 1996.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU jtag 0.5.1\n"
"Report-Msgid-Bugs-To: marcel@telka.sk\n"
"POT-Creation-Date: 2003-09-24 07:07+0200\n"
"PO-Revision-Date: 2004-05-10 08:00-0500\n"
"Last-Translator: Michel Robitaille <robitail@IRO.UMontreal.CA>\n"
"Language-Team: French <traduc@traduc.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: libbrux/cmd/cmd.c:44
#, c-format
msgid "%s: syntax error!\n"
msgstr "%s: erreur de syntaxe!\n"

#: libbrux/cmd/cmd.c:48 libbrux/cmd/help.c:57
#, c-format
msgid "%s: unknown command\n"
msgstr "%s: commande inconnue\n"

#: libbrux/cmd/cmd_detectflash.c:39 src/cmd/eraseflash.c:47
#: src/cmd/flashmem.c:47 src/cmd/peekpoke.c:43 src/cmd/peekpoke.c:88
#: src/cmd/readmem.c:45
msgid "Error: Bus driver missing.\n"
msgstr "Erreur: pilote du bus manquant.\n"

#: libbrux/cmd/cmd_detectflash.c:52
#, c-format
msgid ""
"Usage: %s\n"
"Detect flash memory type connected to a part.\n"
msgstr ""
"Usage: %s\n"
"Détecter un type de mémoire flash connecté.\n"

#: libbrux/cmd/cmd_detectflash.c:59
msgid "detect parameters of flash chips attached to a part"
msgstr "paramètres de détection de modules flahs connectés"

#: libbrux/cmd/help.c:39
msgid ""
"Command list:\n"
"\n"
msgstr ""
"Liste de commandes:\n"
"\n"

#: libbrux/cmd/help.c:41 src/cmd/cable.c:99
#, c-format
msgid "%-13s %s\n"
msgstr "%-13s %s\n"

#: libbrux/cmd/help.c:41
msgid "(no description available)"
msgstr "(pas de description disponible)"

#: libbrux/cmd/help.c:42
msgid ""
"\n"
"Type \"help COMMAND\" for details about a particular command.\n"
msgstr ""
"\n"
"Taper \"help COMMANDE\" pour des détails au sujet d'une commande particulière.\n"

#: libbrux/cmd/help.c:66
#, c-format
msgid ""
"Usage: %s [COMMAND]\n"
"Print short help for COMMAND, or list of available commands.\n"
msgstr ""
"Usage: %s [COMMANDE]\n"
"Afficher une aide sommaire de la COMMANDE ou lister les commandes disponibles.\n"

#: libbrux/cmd/help.c:73
msgid "display this help"
msgstr "afficher l'aide-mémoire"

#: libbrux/cmd/quit.c:44
#, c-format
msgid ""
"Usage: %s\n"
"Exit from %s.\n"
msgstr ""
"Usage: %s\n"
"Quitter à partir de %s.\n"

#: libbrux/cmd/quit.c:51
msgid "exit and terminate this session"
msgstr "quitter et terminer la session"

#: libbrux/flash/amd.c:180
msgid ""
"Chip: AMD Flash\n"
"\tManufacturer: "
msgstr ""
"Module: AMD Flash\n"
"\tManufacturier: "

#: libbrux/flash/amd.c:183
msgid "AMD"
msgstr "AMD"

#: libbrux/flash/amd.c:186
#, c-format
msgid "Unknown manufacturer (ID 0x%04x)"
msgstr "Manufacturier inconnu (ID 0x%04x)"

#: libbrux/flash/amd.c:189
msgid ""
"\n"
"\tChip: "
msgstr ""
"\n"
"\tModule: "

#: libbrux/flash/amd.c:192
msgid "Am29LV640D/Am29LV641D/Am29LV642D"
msgstr "Am29LV640D/Am29LV641D/Am29LV642D"

#: libbrux/flash/amd.c:195
msgid "Am29LV800B"
msgstr "Am29LV800B"

#: libbrux/flash/amd.c:198
#, c-format
msgid "Unknown (ID 0x%04x)"
msgstr "Inconnu (ID 0x%04x)"

#: libbrux/flash/amd.c:201
#, c-format
msgid ""
"\n"
"\tProtected: %04x\n"
msgstr ""
"\n"
"\tProtégé: %04x\n"

#: libbrux/flash/amd.c:268 libbrux/flash/amd.c:280 libbrux/flash/amd.c:292
#: libbrux/flash/detectflash.c:84 libbrux/flash/detectflash.c:114
msgid "AMD/Fujitsu Standard Command Set"
msgstr "AMD/Fujitsu Jeu standard de commandes"

#: libbrux/flash/amd.c:269
msgid "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit"
msgstr "supportés: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit"

#: libbrux/flash/amd.c:281
msgid "supported: AMD 29LV800B; 1x16 Bit"
msgstr "supportés: AMD 29LV800B; 1x16 Bit"

#: libbrux/flash/amd.c:293
msgid "supported: AMD 29LV160; 1x8 Bit"
msgstr "supportés: AMD 29LV160; 1x8 Bit"

#: libbrux/flash/detectflash.c:53 src/readmem.c:54
msgid "Error: Missing bus driver!\n"
msgstr "Erreur: pilote de bus manquant!\n"

#: libbrux/flash/detectflash.c:64 src/flash.c:100
msgid "Flash not found!\n"
msgstr "Flash non détecté!\n"

#: libbrux/flash/detectflash.c:74
msgid "Query identification string:\n"
msgstr "Chaîne de requêtre d'identification:\n"

#: libbrux/flash/detectflash.c:78 libbrux/flash/detectflash.c:108
msgid "null"
msgstr "nul"

#: libbrux/flash/detectflash.c:81 libbrux/flash/detectflash.c:111
msgid "Intel/Sharp Extended Command Set"
msgstr "Jeu étendu de commandes Intel/Sharp"

#: libbrux/flash/detectflash.c:87 libbrux/flash/detectflash.c:117
#: libbrux/flash/intel.c:327 libbrux/flash/intel.c:339
#: libbrux/flash/intel.c:351
msgid "Intel Standard Command Set"
msgstr "Jeu standard de commandes Intel"

#: libbrux/flash/detectflash.c:90 libbrux/flash/detectflash.c:120
msgid "AMD/Fujitsu Extended Command Set"
msgstr "Jeu étendu de commandes AMD/Fujitsu"

#: libbrux/flash/detectflash.c:93 libbrux/flash/detectflash.c:123
msgid "Mitsubishi Standard Command Set"
msgstr "Jeu standard de commandes Mitsubishi"

#: libbrux/flash/detectflash.c:96 libbrux/flash/detectflash.c:126
msgid "Mitsubishi Extended Command Set"
msgstr "Jeu étendu de commandes Mitsubishi"

#: libbrux/flash/detectflash.c:99 libbrux/flash/detectflash.c:129
msgid "Page Write Command Set"
msgstr "Jeu de commande d'écriture de page"

#: libbrux/flash/detectflash.c:102 libbrux/flash/detectflash.c:132
#: libbrux/flash/detectflash.c:176
msgid "unknown!!!"
msgstr "inconnu!!!"

#: libbrux/flash/detectflash.c:105
#, c-format
msgid "\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n"
msgstr "\tJeu de commandes Primary Algorithm et Code ID de contrôle d'interface: 0x%04X (%s)\n"

#: libbrux/flash/detectflash.c:135
#, c-format
msgid "\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n"
msgstr "\tJeu alternatif de commandes Primary Algorithm et Code ID de contrôle d'interface: 0x%04X (%s)\n"

#: libbrux/flash/detectflash.c:138
msgid "Query system interface information:\n"
msgstr "Requête d'information d'interface système:\n"

#: libbrux/flash/detectflash.c:139
#, c-format
msgid "\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n"
msgstr "\tVcc logique Puissance minimum Écri/Efface ou Voltage d'écriture: %d mV\n"

#: libbrux/flash/detectflash.c:140
#, c-format
msgid "\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n"
msgstr "\tVcc logique Puissance maximum Écri/Efface ou Voltage d'écriture: %d mV\n"

#: libbrux/flash/detectflash.c:141
#, c-format
msgid "\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n"
msgstr "\tVpp [Programmation] puissance minimum Écriture/Efface voltage: %d mV\n"

#: libbrux/flash/detectflash.c:142
#, c-format
msgid "\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n"
msgstr "\tVpp [Programmation] puissance maximum Écriture/Efface voltage: %d mV\n"

#: libbrux/flash/detectflash.c:143
#, c-format
msgid "\tTypical timeout per single byte/word program: %d us\n"
msgstr "\tDélai d'expiration typique par programme simple octet/mot: %d us\n"

#: libbrux/flash/detectflash.c:144
#, c-format
msgid "\tTypical timeout for maximum-size multi-byte program: %d us\n"
msgstr "\tDélai d'expiration typique pour la taille maximale par programme multi-octets: %d us\n"

#: libbrux/flash/detectflash.c:145
#, c-format
msgid "\tTypical timeout per individual block erase: %d ms\n"
msgstr "\tDélai d'expiration typique par effacement individuel de blocs: %d ms\n"

#: libbrux/flash/detectflash.c:146
#, c-format
msgid "\tTypical timeout for full chip erase: %d ms\n"
msgstr "\tDélai d'expiration typique pour un effacement complet du module: %d ms\n"

#: libbrux/flash/detectflash.c:147
#, c-format
msgid "\tMaximum timeout for byte/word program: %d us\n"
msgstr "\tDélai d'expiration maximal pour un programme octer/mot: %d us\n"

#: libbrux/flash/detectflash.c:148
#, c-format
msgid "\tMaximum timeout for multi-byte program: %d us\n"
msgstr "\tDélai d'expiration maximum pour programme multi-octets: %d us\n"

#: libbrux/flash/detectflash.c:149
#, c-format
msgid "\tMaximum timeout per individual block erase: %d ms\n"
msgstr "\tDélai d'expiration maximum par effacement individuel de blocs: %d ms\n"

#: libbrux/flash/detectflash.c:150
#, c-format
msgid "\tMaximum timeout for chip erase: %d ms\n"
msgstr "\tDélai d'expiration maximum pour un effacement complet du module: %d ms\n"

#: libbrux/flash/detectflash.c:153
msgid "Device geometry definition:\n"
msgstr "Définition de la géométrie du périphérique:\n"

#: libbrux/flash/detectflash.c:154
#, c-format
msgid "\tDevice Size: %d B (%d KiB, %d MiB)\n"
msgstr "\tTaille du périphérique: %d O (%d KiB, %d MiB)\n"

#: libbrux/flash/detectflash.c:161
msgid "x8"
msgstr "x8"

#: libbrux/flash/detectflash.c:164
msgid "x16"
msgstr "x16"

#: libbrux/flash/detectflash.c:167
msgid "x8/x16"
msgstr "x8/x16"

#: libbrux/flash/detectflash.c:170
msgid "x32"
msgstr "x32"

#: libbrux/flash/detectflash.c:173
msgid "x16/x32"
msgstr "x16/x32"

#: libbrux/flash/detectflash.c:179
#, c-format
msgid "\tFlash Device Interface Code description: 0x%04X (%s)\n"
msgstr "\tDescription du code de l'interface du module: 0x%04X (%s)\n"

#: libbrux/flash/detectflash.c:180
#, c-format
msgid "\tMaximum number of bytes in multi-byte program: %d\n"
msgstr "\tNombre maximum d'octets d'un programme multi-octest: %d\n"

#: libbrux/flash/detectflash.c:181
#, c-format
msgid "\tNumber of Erase Block Regions within device: %d\n"
msgstr "\tNumbre de régions de blocs d'effacement à l'intérieur du périphérique: %d\n"

#: libbrux/flash/detectflash.c:182
msgid "\tErase Block Region Information:\n"
msgstr "\tInformation sur la région du bloc d'effacement:\n"

#: libbrux/flash/detectflash.c:187
#, c-format
msgid "\t\tRegion %d:\n"
msgstr "\t\tRégion %d:\n"

#: libbrux/flash/detectflash.c:188
#, c-format
msgid "\t\t\tErase Block Size: %d B (%d KiB)\n"
msgstr "\t\t\tTaille du bloc d'effacement: %d B (%d KiB)\n"

#: libbrux/flash/detectflash.c:191
#, c-format
msgid "\t\t\tNumber of Erase Blocks: %d\n"
msgstr "\t\t\tNombre de blocs d'effacement: %d\n"

#: libbrux/flash/intel.c:104
#, c-format
msgid "Manufacturer: %s\n"
msgstr "Manufacturier: %s\n"

#: libbrux/flash/intel.c:107
#, c-format
msgid "Unknown manufacturer (0x%04X)!\n"
msgstr "Manufacturier inconnu (0x%04X)!\n"

#: libbrux/flash/intel.c:111
msgid "Chip: "
msgstr "Module: "

#: libbrux/flash/intel.c:142
#, c-format
msgid "Unknown (0x%02X)!\n"
msgstr "Inconnu (0x%02X)!\n"

#: libbrux/flash/intel.c:201
msgid "flash: invalid command seq\n"
msgstr "flash: séquence de commande invalide\n"

#: libbrux/flash/intel.c:204
msgid "flash: low vpen\n"
msgstr "flash: vpen bas\n"

#: libbrux/flash/intel.c:207
msgid "flash: block locked\n"
msgstr "flash: bloc verrouillé\n"

#: libbrux/flash/intel.c:229
msgid "flash: unknown error while unblocking\n"
msgstr "flash: erreur inconnue lors du déverrouillage\n"

#: libbrux/flash/intel.c:248
msgid "flash: unknown error while programming\n"
msgstr "flash: erreur inconnue lors de la programmation\n"

#: libbrux/flash/intel.c:328
msgid "supported: 28Fxxxx, 2 x 16 bit"
msgstr "supportés: 28Fxxxx, 2 x 16 bit"

#: libbrux/flash/intel.c:340
msgid "supported: 28Fxxxx, 1 x 16 bit"
msgstr "supportés: 28Fxxxx, 1 x 16 bit"

#: libbrux/flash/intel.c:352
msgid "supported: 28Fxxxx, 1 x 8 bit"
msgstr "supportés: 28Fxxxx, 1 x 8 bit"

#: src/bus/bcm1250.c:104
#, c-format
msgid "Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "Pilote de bus compatible Broadcom BCM1250 via BSR (JTAG No de pièce %d)\n"

#: src/bus/bcm1250.c:275
msgid "Broadcom BCM1250 compatible bus driver via BSR"
msgstr "pilote de bus compatible Broadcom BCM1250 via BSR"

#: src/bus/bcm1250.c:317 src/bus/bcm1250.c:326 src/bus/bcm1250.c:333
#: src/bus/bcm1250.c:338 src/bus/bcm1250.c:343 src/bus/ixp425.c:280
#: src/bus/ixp425.c:289 src/bus/ixp425.c:298 src/bus/ixp425.c:305
#: src/bus/ixp425.c:310 src/bus/pxa2x0.c:386 src/bus/pxa2x0.c:395
#: src/bus/pxa2x0.c:404 src/bus/pxa2x0.c:413 src/bus/pxa2x0.c:420
#: src/bus/pxa2x0.c:425 src/bus/pxa2x0.c:430 src/bus/pxa2x0.c:435
#: src/bus/s3c4510x.c:339 src/bus/s3c4510x.c:348 src/bus/s3c4510x.c:357
#: src/bus/s3c4510x.c:366 src/bus/s3c4510x.c:373 src/bus/sa1110.c:294
#: src/bus/sa1110.c:303 src/bus/sa1110.c:312 src/bus/sa1110.c:319
#: src/bus/sa1110.c:324 src/bus/sa1110.c:329 src/bus/sh7727.c:326
#: src/bus/sh7727.c:335 src/bus/sh7727.c:346 src/bus/sh7727.c:355
#: src/bus/sh7727.c:362 src/bus/sh7727.c:367 src/bus/sh7727.c:372
#: src/bus/sh7727.c:377 src/bus/sh7750r.c:308 src/bus/sh7750r.c:317
#: src/bus/sh7750r.c:326 src/bus/sh7750r.c:335 src/bus/sh7750r.c:342
#: src/bus/sh7750r.c:347 src/bus/sh7750r.c:352 src/bus/sh7750r.c:357
#: src/bus/sh7751r.c:301 src/bus/sh7751r.c:310 src/bus/sh7751r.c:319
#: src/bus/sh7751r.c:328 src/bus/sh7751r.c:335 src/bus/sh7751r.c:340
#: src/cmd/get.c:63 src/cmd/set.c:77
#, c-format
msgid "signal '%s' not found\n"
msgstr "signal '%s' non repéré\n"

#: src/bus/buses.c:69 src/cmd/include.c:47 src/detect.c:252 src/jtag.c:159
#: src/jtag.c:270
msgid "Out of memory\n"
msgstr "Mémoire épuisée\n"

#: src/bus/ixp425.c:125
#, c-format
msgid "Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel IXP425 via BSR (JTAG No de pièce %d)\n"

#: src/bus/ixp425.c:238
msgid "Intel IXP425 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel IXP425 via BSR"

#: src/bus/pxa2x0.c:119
#, c-format
msgid "Intel PXA2x0 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR (JTAG No de pièce %d)\n"

#: src/bus/pxa2x0.c:278
msgid "Static Chip Select 0"
msgstr "Sélection statique du module 0"

#: src/bus/pxa2x0.c:317
msgid "Memory Mapped registers (Memory Ctl)"
msgstr "Registres mémoire mappé (Ctl Mémoire)"

#: src/bus/pxa2x0.c:344
msgid "Intel PXA2x0 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel PXA2x0 via BSR"

#: src/bus/s3c4510x.c:128
#, c-format
msgid "Samsung S3C4510B compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Samsung S3C4510B via BSR (JTAG no de pièce %d)\n"

#: src/bus/s3c4510x.c:297
msgid "Samsung S3C4510B compatible bus driver via BSR"
msgstr "pilote de bus compatible Samsung S3C4510B via BSR"

#: src/bus/sa1110.c:108
#, c-format
msgid "Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Intel SA-1110 via BSR (JTAG no de pièce %d)\n"

#: src/bus/sa1110.c:252
msgid "Intel SA-1110 compatible bus driver via BSR"
msgstr "pilote de bus compatible Intel SA-1110 via BSR"

#: src/bus/sh7727.c:109
#, c-format
msgid "Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Hitachi SH7727 via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7727.c:267
msgid "Error: Invalid bus width (MD3 = MD4 = 0)!\n"
msgstr "ERREUR: largeur de bus invalide (MD3 = MD4 = 0)!\n"

#: src/bus/sh7727.c:284
msgid "Hitachi SH7727 compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7727 via BSR"

#: src/bus/sh7750r.c:101
#, c-format
msgid "Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Hitachi SH7750R via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7750r.c:266
msgid "Hitachi SH7750R compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7750R via BSR"

#: src/bus/sh7751r.c:99
#, c-format
msgid "Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n"
msgstr "pilote de bus compatible Hitachi SH7751R via BSR (JTAG no de pièce %d)\n"

#: src/bus/sh7751r.c:259
msgid "Hitachi SH7751R compatible bus driver via BSR"
msgstr "pilote de bus compatible Hitachi SH7751R via BSR"

#: src/cmd/bit.c:52 src/cmd/bus.c:46 src/cmd/dr.c:48 src/cmd/get.c:52
#: src/cmd/initbus.c:46 src/cmd/instruction.c:44 src/cmd/part.c:46
#: src/cmd/print.c:56 src/cmd/register.c:50 src/cmd/set.c:53
#: src/cmd/signal.c:49
msgid "Run \"detect\" first.\n"
msgstr "Eéxcuer \"détecter\" d'abord.\n"

#: src/cmd/bit.c:57 src/cmd/dr.c:53 src/cmd/get.c:57 src/cmd/initbus.c:51
#: src/cmd/instruction.c:49 src/cmd/register.c:55 src/cmd/set.c:58
#: src/cmd/signal.c:54
#, c-format
msgid "%s: no active part\n"
msgstr "%s: aucune pièce active\n"

#: src/cmd/bit.c:64
msgid "missing Boundary Scan Register (BSR)\n"
msgstr "registre Boundary Scan Register (BSR) manquant\n"

#: src/cmd/bit.c:73
msgid "invalid boundary bit number\n"
msgstr "numéro de bit de limite invalide\n"

#: src/cmd/bit.c:77
msgid "duplicate bit declaration\n"
msgstr "déclaration double de bit\n"

#: src/cmd/bit.c:114 src/cmd/instruction.c:95 src/cmd/register.c:71
#: src/cmd/register.c:85 src/cmd/signal.c:66 src/detect.c:194 src/detect.c:217
msgid "out of memory\n"
msgstr "mémoire épuisée\n"

#: src/cmd/bit.c:126
msgid "invalid control bit number\n"
msgstr "numéro de bit de contrôle invalide\n"

#: src/cmd/bit.c:148
#, c-format
msgid ""
"Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\n"
"Define new BSR (Boundary Scan Register) bit for SIGNAL, with\n"
"DEFAULT value.\n"
"\n"
"NUMBER        Bit number in the BSR\n"
"TYPE          Bit type, valid values are I, O, B, C, and X\n"
"DEFAULT       Default (safe) bit value, valid values are 1, 0, ?\n"
"SIGNAL        Associated signal name\n"
"CBIT          Control bit number\n"
"CVAL          Control value\n"
"CSTATE        Control state, valid state is only Z\n"
msgstr ""
"Usage: %s NUMÉRO TYPE DÉFAUT SIGNAL [BITC VALC ÉTATC]\n"
"Définir le nouveau bit du registre BSR (Boundary Scan Register) pour le SIGNAL, avec\n"
"la valeur par DÉFAUT.\n"
"\n"
"NUMÉRO        numéro du bit du BSR\n"
"TYPE          type de bit, valeurs permises: I, O, B, C et X\n"
"DÉFAUT        valeur du bit par défaut (sûre), valeurs permises:  1, 0, ?\n"
"SIGNAL        nom du signal associé\n"
"BITC          numéro de bit de contrôle\n"
"VALC          valeur de contrôle\n"
"ÉTATC         état de contrôle, état permis est seulement Z\n"

#: src/cmd/bit.c:164
msgid "define new BSR bit"
msgstr "définir un nouveau bit BSR"

#: src/cmd/bus.c:54
#, c-format
msgid "%s: invalid bus number\n"
msgstr "%s: numéro de bus invalide\n"

#: src/cmd/bus.c:67
#, c-format
msgid ""
"Usage: %s BUS\n"
"Change active bus.\n"
"\n"
"BUS           bus number\n"
msgstr ""
"Usage: %s BUS\n"
"Changer le bus actif.\n"
"\n"
"BUS           numéro de bus\n"

#: src/cmd/bus.c:76
msgid "change active bus"
msgstr "changer le bus actif"

#: src/cmd/cable.c:53
#, c-format
msgid "Unknown connection type: %s\n"
msgstr "Type de connexion inconnue: %s\n"

#: src/cmd/cable.c:64
msgid "Error: Cable connection failed!\n"
msgstr "Error: échec de la connexion par cable!\n"

#: src/cmd/cable.c:69
msgid "Error: Cable initialization failed!\n"
msgstr "Error: échec de l'initialisation par cable!\n"

#: src/cmd/cable.c:86
#, c-format
msgid ""
"Usage: %s PORTADDR CABLE\n"
"Usage: %s DEV CABLE\n"
"Select JTAG cable connected to parallel port.\n"
"\n"
"PORTADDR   parallel port address (e.g. 0x378)\n"
"CABLE      cable type\n"
"DEV        ppdev device (e.g. /dev/parport0)\n"
"\n"
"List of supported cables:\n"
"%-13s No cable connected\n"
msgstr ""
"Usage: %s ADDR_PORT CABLE\n"
"Usage: %s PÉRIPHÉRIQUE CABLE\n"
"Sélectionner le cable JTAG connecté au port parallèle.\n"
"\n"
"ADDR_PORT  adresse du port parallèle (i.e. 0x378)\n"
"CABLE      type de cable\n"
"PÉR        PÉRiphérique (i.e. /dev/parport0)\n"
"\n"
"Lists des cables supportés:\n"
"%-13s Aucun cable connecté\n"

#: src/cmd/cable.c:104
msgid "select JTAG cable"
msgstr "sélectionner le cable JTAG"

#: src/cmd/cmd.c:99
#, c-format
msgid "Error: Cable not configured. Please use '%s' command first!\n"
msgstr "ERREUR: cable non configuré. SVP utiliser la commande '%s' d'abord!\n"

#: src/cmd/detect.c:68
#, c-format
msgid ""
"Usage: %s\n"
"Detect parts on the JTAG chain.\n"
"\n"
"Output from this command is a list of the detected parts.\n"
"If no parts are detected other commands may not work properly.\n"
msgstr ""
"Usage: %s\n"
"Détecter les pièces sur la chaîne JTAG.\n"
"\n"
"La sortie de cette commande est une liste de pièces détectées.\n"
"Si aucune pièce n'est détectée, les autres commandes peuvent ne pas fonctionner correctement.\n"

#: src/cmd/detect.c:78
msgid "detect parts on the JTAG chain"
msgstr "pièces détectés sur la caîne JTAG"

#: src/cmd/discovery.c:51
#, c-format
msgid ""
"Usage: %s\n"
"Discovery of unknown parts in the JTAG chain.\n"
"\n"
"'%s' attempts to detect these parameters of an unknown JTAG\n"
"chain:\n"
" 1. IR (instruction register) length\n"
" 2. DR (data register) length for all possible instructions\n"
"\n"
"Warning: This may be dangerous for some parts (especially if the\n"
"part doesn't have TRST signal).\n"
msgstr ""
"Usage: %s\n"
"Découvrir les pièces inconnues sur la chaîne JTAG.\n"
"\n"
"'%s' tentatives pour détecter ces paramètres sur une chaîne JTAG inconnue:\n"
" 1. IR (registre d'instruction register) longueur\n"
" 2. DR (registre de données) longueurs de toutes les instructions possibles\n"
"\n"
"AVERTISSMENT: ceci peut être dangereus pour certaintes pièces (spécialement si celles-ci\n"
"n'ont pas de signal TRST).\n"

#: src/cmd/discovery.c:66
msgid "discovery of unknown parts in the JTAG chain"
msgstr "découverte des pièces inconnues dans la chaîne JTAG"

#: src/cmd/dr.c:67
#, c-format
msgid "%s: part without active instruction\n"
msgstr "%s: pièces sans instruction active\n"

#: src/cmd/dr.c:71
#, c-format
msgid "%s: part without active data register\n"
msgstr "%s: pièces sans registre actif de données\n"

#: src/cmd/dr.c:79
#, c-format
msgid "%s\n"
msgstr "%s\n"

#: src/cmd/dr.c:88
#, c-format
msgid ""
"Usage: %s [DIR]\n"
"Display input or output data register content.\n"
"\n"
"DIR           requested data register; possible values: 'in' for\n"
"                input and 'out' for output; default is 'out'\n"
msgstr ""
"Usage: %s [DIR]\n"
"Afficher le contenu des registres d'entrée et de sortie de données.\n"
"\n"
"DIR           registre de données interrogé; valeurs possibles: 'in' pour\n"
"                l'entrée et 'out' pour la sortie; par défaut 'out'\n"

#: src/cmd/dr.c:98
msgid "display active data register for a part"
msgstr "afficher le registre actif de données pour une pièce"

#: src/cmd/endian.c:42
msgid "Endianess for external files: big\n"
msgstr "système de poids fort/faible des fichiers externes: gros (big endian)\n"

#: src/cmd/endian.c:44
msgid "Endianess for external files: little\n"
msgstr "système de poids fort/faible des fichiers externes: petit (little endian)\n"

#: src/cmd/endian.c:65
#, c-format
msgid ""
"Usage: %s\n"
"Set or print endianess for external files.\n"
msgstr ""
"Usage: %s\n"
"Initialiser ou afficher le système de poids fort/faible (big/little endian) des fichiers externes.\n"

#: src/cmd/endian.c:72
msgid "set/print endianess"
msgstr "Initialiser ou afficher le système de poids fort/faible (big/little endian)."

#: src/cmd/eraseflash.c:65
#, c-format
msgid ""
"Usage: %s ADDR BLOCKS\n"
"Erase flash memory from ADDR.\n"
"\n"
"ADDR       target addres for erasing block\n"
"BLOCKS     number of blocks to erase\n"
"\n"
"ADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
"Supported Flash Memories:\n"
msgstr ""
"Usage: %s ADR BLOCS\n"
"Effacer la mémoire flash à partir de l'ADResse.\n"
"\n"
"ADR        ADRessse cible pour effacer un bloc\n"
"BLOCS      numbre de blocs à effacer\n"
"\n"
"ADR et BLOCS peuvent être en valeur décimal ou hexadécimal (préfixé avec 0x).\n"
"\n"
"Mémoires flash supportées:\n"

#: src/cmd/eraseflash.c:77 src/cmd/flashmem.c:89
#, c-format
msgid ""
"%s\n"
"     %s\n"
msgstr ""
"%s\n"
"     %s\n"

#: src/cmd/eraseflash.c:82
msgid "erase flash memory by number of blocks"
msgstr "effacer la mémoire flash par numéro de bloc"

#: src/cmd/flashmem.c:57 src/cmd/include.c:54 src/cmd/script.c:43
#: src/jtag.c:280
#, c-format
msgid "Unable to open file `%s'!\n"
msgstr "Incapable d'ouvrir le fichier `%s'!\n"

#: src/cmd/flashmem.c:75
#, c-format
msgid ""
"Usage: %s ADDR FILENAME\n"
"Usage: %s FILENAME\n"
"Program FILENAME content to flash memory.\n"
"\n"
"ADDR       target address for raw binary image\n"
"FILENAME   name of the input file\n"
"%-10s FILENAME is in MS .bin format (for WinCE)\n"
"\n"
"ADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
"Supported Flash Memories:\n"
msgstr ""
"Usage: %s ADR FICHIER\n"
"Usage: %s FICHIER\n"
"Programmer le contenu de la mémoire flash avec le FICHIER.\n"
"\n"
"ADR        ADResse cible d'une image binaire brute\n"
"FICHIER    nom du FICHIER d'entrée\n"
"%-10s FICHIER est un format MS .bin (pour WinCE)\n"
"\n"
"ADR et BLOCS peuvent être en valeur décimal ou hexadécimal (préfixé avec 0x).\n"
"\n"
"Mémoires flahs supportées:\n"

#: src/cmd/flashmem.c:94
msgid "burn flash memory with data from a file"
msgstr "brûler la mémoire flahs avec les données à partir d'un fichier"

#: src/cmd/frequency.c:39
#, c-format
msgid "Current TCK frequency is %u Hz\n"
msgstr "Fréquence courant TCK est %u Hz\n"

#: src/cmd/frequency.c:49
#, c-format
msgid "Setting TCK frequency to %u Hz\n"
msgstr "Initialisation de la fréquence TCK à %u Hz\n"

#: src/cmd/frequency.c:59
#, c-format
msgid ""
"Usage: %s [FREQ]\n"
"Change TCK frequency to FREQ or print current TCK frequency.\n"
"\n"
"FREQ is in hertz. It's a maximum TCK frequency for JTAG interface.\n"
"In some cases the TCK frequency is less than FREQ, but the frequency\n"
"is never more than FREQ. Maximum supported frequency depends on JTAG\n"
"adapter.\n"
"\n"
"FREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\n"
"Use 0 for FREQ to disable frequency limit.\n"
msgstr ""
"Usage: %s [FRÉQUENCE]\n"
"Modifier ou afficher la fréquence courante TCK.\n"
"\n"
"FRÉQUENCE est en hertz. C'est la férquence maximale TCK pour une interface JTAG.\n"
"Dans certains cas, la fréquence TCK est inférieure à la FRÉQUENCE mais jamais\n"
"plus que la FRÉQUENCE. La fréquence maximum supportée dépend de l'adapteur JTAG.\n"
"\n"
"FRÉQUENCE doit être un entier non signé. La fréquence minimale permise est 1 Hz.\n"
"Utilise 0 comme valeur pour désactiver la limite de fréquence.\n"

#: src/cmd/frequency.c:74
msgid "setup JTAG frequency"
msgstr "initialisation de la fréquence JTAG"

#: src/cmd/get.c:68
#, c-format
msgid "%s = %d\n"
msgstr "%s = %d\n"

#: src/cmd/get.c:77
#, c-format
msgid ""
"Usage: %s SIGNAL\n"
"Get signal state from output BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        signal name (from JTAG declaration file)\n"
msgstr ""
"Usage: %s SIGNAL\n"
"Obtenir l'état du signal de la sortie BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"

#: src/cmd/get.c:86
msgid "get external signal value"
msgstr "obtenir la valeur externe du signal"

#: src/cmd/include.c:65
#, c-format
msgid ""
"Usage: %s FILENAME\n"
"Run command sequence from external FILENAME from the repository.\n"
"\n"
"FILENAME      Name of the file with commands\n"
msgstr ""
"Usage: %s FICHIER\n"
"Exécuter une séquence de commandes à partir du FICHIER du dépôt externe.\n"
"\n"
"FICHIER       nom du fichier contenant les commandes\n"

#: src/cmd/include.c:74
msgid "include command sequence from external repository"
msgstr "inclure une séquence de commandes à partir du dépôt externe"

#: src/cmd/initbus.c:59
msgid "bus initialization failed!\n"
msgstr "initialisation du bus a échoué!\n"

#: src/cmd/initbus.c:67
#, c-format
msgid "Unknown bus: %s\n"
msgstr "bus inconnu: %s\n"

#: src/cmd/initbus.c:78
#, c-format
msgid ""
"Usage: %s BUSNAME\n"
"Initialize new bus driver for active part.\n"
"\n"
"BUSNAME       Name of the bus\n"
"\n"
"List of available buses:\n"
msgstr ""
"Usage: %s BUS\n"
"Initialiser le pilote du bus pour la pièce active.\n"
"\n"
"BUS           nom du bus\n"
"\n"
"Liste des bus disponibles:\n"

#: src/cmd/initbus.c:87
#, c-format
msgid "%-10s %s\n"
msgstr "%-10s %s\n"

#: src/cmd/initbus.c:92
msgid "initialize bus driver for active part"
msgstr "initialiser le pilote du bus pour la pièce active."

#: src/cmd/instruction.c:58
#, c-format
msgid "%s: unknown instruction '%s'\n"
msgstr "%s: instruction inconnue '%s'\n"

#: src/cmd/instruction.c:69
msgid "instruction length is already set and used\n"
msgstr "la longueur d'instruction est déjà initialisée et utilisée\n"

#: src/cmd/instruction.c:84
msgid "invalid instruction length\n"
msgstr "longueur d'instruction invalide\n"

#: src/cmd/instruction.c:89
#, c-format
msgid "Instruction '%s' already defined\n"
msgstr "Instruction '%s' est déjà définie\n"

#: src/cmd/instruction.c:104
#, c-format
msgid "unknown data register '%s'\n"
msgstr "registre de données inconnu '%s'\n"

#: src/cmd/instruction.c:118
#, c-format
msgid ""
"Usage: %s INSTRUCTION\n"
"Usage: %s length LENGTH\n"
"Usage: %s INSTRUCTION CODE REGISTER\n"
"Change active INSTRUCTION for a part or declare new instruction.\n"
"\n"
"INSTRUCTION   instruction name (e.g. BYPASS)\n"
"LENGTH        common instruction length\n"
"CODE          instruction code (e.g. 11111)\n"
"REGISTER      default data register for instruction (e.g. BR)\n"
msgstr ""
"Usage: %s INSTRUCTION\n"
"Usage: %s longueur LONGUEUR\n"
"Usage: %s INSTRUCTION CODE REGISTRE\n"
"Changer l'INSTRUCTION active pour une pièce ou déclarer une nouvelle instruction.\n"
"\n"
"INSTRUCTION   nom de l'instruction (i.e. BYPASS)\n"
"LENGTH        longueur commune d'instruction\n"
"CODE          code d'instruction (i.e. 11111)\n"
"REGISTRE      registre de données pour l'instruction (i.e. BR)\n"

#: src/cmd/instruction.c:132
msgid "change active instruction for a part or declare new instruction"
msgstr "changer l'instruction active pour une pièce ou déclarer une nouvelle instruction."

#: src/cmd/part.c:54
#, c-format
msgid "%s: invalid part number\n"
msgstr "%s: numéro de pièce invalide\n"

#: src/cmd/part.c:67
#, c-format
msgid ""
"Usage: %s PART\n"
"Change active part for current JTAG chain.\n"
"\n"
"PART          part number\n"
msgstr ""
"Usage: %s PIÈCE\n"
"Changer la pièce active pour la chaîne courant JTAG.\n"
"\n"
"PIÈCE         numéro de pièce\n"

#: src/cmd/part.c:76
msgid "change active part for current JTAG chain"
msgstr "changer la pièce active pour la chaîne courante JTAG"

#: src/cmd/peekpoke.c:53
#, c-format
msgid "bus_read(0x%08x) = 0x%08X (%i)\n"
msgstr "bus_read(0x%08x) = 0x%08X (%i)\n"

#: src/cmd/peekpoke.c:62
#, c-format
msgid ""
"Usage: %s ADDR\n"
"Read a single word (bus width size).\n"
"\n"
"ADDR       address to read from\n"
"\n"
"ADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
msgstr ""
"Usage: %s ADR\n"
"Lire un mot simple (taille de la largeur de bus).\n"
"\n"
"ADR        adresse de lecture\n"
"\n"
"ADR peut être en décimal ou hexadécimal (préfixé par 0x).\n"
"\n"

#: src/cmd/peekpoke.c:74
msgid "read a single word"
msgstr "lire un mot simple"

#: src/cmd/peekpoke.c:105
#, c-format
msgid ""
"Usage: %s ADDR VAL\n"
"Write a single word (bus width size).\n"
"\n"
"ADDR       address to write\n"
"VAL        value to write\n"
"\n"
"ADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n"
"\n"
msgstr ""
"Usage: %s ADR VAL\n"
"Écrire un mot simple (taille de la largeur de bus).\n"
"\n"
"ADR        adresse d'écriture\n"
"VAL        valeur à écrire\n"
"\n"
"ADR et VAL peuvent être en décimal ou en hexadécimal (préfixé par 0x).\n"
"\n"

#: src/cmd/peekpoke.c:118
msgid "write a single word"
msgstr "écrire un mot simple"

#: src/cmd/print.c:68
#, c-format
msgid " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"
msgstr " No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/cmd/print.c:72 src/cmd/print.c:75 src/cmd/print.c:79
#, c-format
msgid "(%d) String conversion failed!\n"
msgstr "(%d) la conversion de chaîne a échoué!\n"

#: src/cmd/print.c:73 src/cmd/print.c:77
msgid "Manufacturer"
msgstr "Manufacturier"

#: src/cmd/print.c:73 src/cmd/print.c:77
msgid "Part"
msgstr "Pièce"

#: src/cmd/print.c:73 src/cmd/print.c:77
msgid "Stepping"
msgstr "Pas"

#: src/cmd/print.c:73 src/cmd/print.c:77
msgid "Instruction"
msgstr "Instruction"

#: src/cmd/print.c:73 src/cmd/print.c:77
msgid "Register"
msgstr "Registre"

#: src/cmd/print.c:90 src/part/part.c:309
#, c-format
msgid " %3d "
msgstr " %3d "

#: src/cmd/print.c:101
#, c-format
msgid ""
"\n"
"Active bus:\n"
"*%d: "
msgstr ""
"\n"
"Bus actif:\n"
"*%d: "

#: src/cmd/print.c:106
#, c-format
msgid "Error in bus area discovery at 0x%08llX\n"
msgstr "ERREUR dans la zone de découverte du bus à 0x%08llX\n"

#: src/cmd/print.c:111
#, c-format
msgid "\tstart: 0x%08X, length: 0x%08llX, data width: %d bit, (%s)\n"
msgstr "\tdébut: 0x%08X, longueur: 0x%08llX, largeur des données: %d bits, (%s)\n"

#: src/cmd/print.c:113
#, c-format
msgid "\tstart: 0x%08X, length: 0x%08llX, data width: %d bit\n"
msgstr "\tdébut: 0x%08X, longueur: 0x%08llX, largeur des données: %d bits\n"

#: src/cmd/print.c:128
#, c-format
msgid "*%d: "
msgstr "*%d: "

#: src/cmd/print.c:130
#, c-format
msgid "%d: "
msgstr "%d: "

#: src/cmd/print.c:141
#, c-format
msgid ""
"Usage: %s [chain|bus]\n"
"Display JTAG chain status.\n"
"\n"
"Display list of the parts connected to the JTAG chain including\n"
"part number and current (active) instruction and data register.\n"
msgstr ""
"Usage: %s [chaîne|bus]\n"
"Afficher l'état de la chaîne JTAG.\n"
"\n"
"Afficher la liste des pièces connectés à la chaîne JTAG incluant\n"
"le numéro de pièce, l'instruiction courante (active) et le registre de données.\n"

#: src/cmd/print.c:151
msgid "display JTAG chain list/status"
msgstr "afficher la liste/état de la chaîne JTAG"

#: src/cmd/readmem.c:54
#, c-format
msgid "Unable to create file `%s'!\n"
msgstr "Incapable de créer le fichier `%s'!\n"

#: src/cmd/readmem.c:67
#, c-format
msgid ""
"Usage: %s ADDR LEN FILENAME\n"
"Copy device memory content starting with ADDR to FILENAME file.\n"
"\n"
"ADDR       start address of the copied memory area\n"
"LEN        copied memory length\n"
"FILENAME   name of the output file\n"
"\n"
"ADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n"
msgstr ""
"Usage: %s ADR LONG FICHIER\n"
"Copier le contenu de la mémoire du périphérique débutant à l'ADR dans le FICHIER.\n"
"\n"
"ADR        adresse de départ de la zone mémoire à copier\n"
"LONG       longeur de la zone mémoire à copier\n"
"FICHIER    nom du fichier de sortie\n"
"\n"
"ADR et LONG peuvent être en décimal ou hexadécimal (préfixe par 0x).\n"

#: src/cmd/readmem.c:80
msgid "read content of the memory and write it to file"
msgstr "lire le contenu de la mémoire et l'écrire dans le fichier"

#: src/cmd/register.c:65
#, c-format
msgid "Data register '%s' already defined\n"
msgstr "registre de données '%s' est déjà défini\n"

#: src/cmd/register.c:103
#, c-format
msgid ""
"Usage: %s NAME LENGTH\n"
"Define new data register with specified NAME and LENGTH.\n"
"\n"
"NAME          Data register name\n"
"LENGTH        Data register length\n"
msgstr ""
"Usage: %s NOM LONGUEUR\n"
"Définir un nouveau registre de données avec un NOM et une LONGUER spécifique.\n"
"\n"
"NOM           nom du registre de données\n"
"LONGUEUR      longueur du registre de données\n"

#: src/cmd/register.c:113
msgid "define new data register for a part"
msgstr "définir un nouveau registre de données pour la pièce"

#: src/cmd/script.c:52
#, c-format
msgid ""
"Usage: %s FILENAME\n"
"Run command sequence from external FILENAME.\n"
"\n"
"FILENAME      Name of the file with commands\n"
msgstr ""
"Usage: %s FICHIER\n"
"Exécuter une séquence de commandes à partir d'un FICHIER externe.\n"
"\n"
"FICHIER        nom du fichier contenant les commande\n"

#: src/cmd/script.c:61
msgid "run command sequence from external file"
msgstr "exécuter une séquence de commandes à partir d'un FICHIER externe"

#: src/cmd/set.c:89
#, c-format
msgid ""
"Usage: %s SIGNAL DIR [DATA]\n"
"Set signal state in input BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        signal name (from JTAG declaration file)\n"
"DIR           requested signal direction; possible values: 'in' or 'out'\n"
"DATA          desired output signal value ('0' or '1'); used only if DIR\n"
"                is 'out'\n"
msgstr ""
"Usage: %s SIGNAL DIR [DONNÉE]\n"
"Initialiser l'état du signal à l'entrée du BSR (Boundary Scan Register).\n"
"\n"
"SIGNAL        nom du signal (à partir du fichier de déclaration JTAG)\n"
"DIR           direction requise du signal; valeurs possibles: 'in' ou 'out'\n"
"DATA          valeur de sortie du signal ('0' ou '1'); utilisé seulement si DIR\n"
"                est à 'out'\n"

#: src/cmd/set.c:101
msgid "set external signal value"
msgstr "initialiser la valeur d'un signal externe"

#: src/cmd/shift.c:60
#, c-format
msgid ""
"Usage: %s\n"
"Usage: %s\n"
"Shift instruction or data register through JTAG chain.\n"
msgstr ""
"Usage: %s\n"
"Usage: %s\n"
"Décaler le registre d'instruction ou de données à travers la chaîne JTAG.\n"

#: src/cmd/shift.c:68
msgid "shift data/instruction registers through JTAG chain"
msgstr "décaler le registre instruction/données à travers la chaîne JTAG"

#: src/cmd/signal.c:60
#, c-format
msgid "Signal '%s' already defined\n"
msgstr "Signal '%s' déjà défini\n"

#: src/cmd/signal.c:80
#, c-format
msgid ""
"Usage: %s SIGNAL [PINLIST...]\n"
"Define new signal with name SIGNAL for a part.\n"
"\n"
"SIGNAL        New signal name\n"
"PINLIST       List of pins for a signal (not used)\n"
msgstr ""
"Usage: %s SIGNAL [BROCHES...]\n"
"Définir un nouveau signal avec le nom SIGNAL pour la pièce.\n"
"\n"
"SIGNAL        nouveau nom de signal\n"
"BROCHES       liste debroches pour le signal (non utilisé)\n"

#: src/cmd/signal.c:90
msgid "define new signal for a part"
msgstr "définir un nouveau signal pour une pièce"

#: src/detect.c:56
#, c-format
msgid "Cannot open %s\n"
msgstr "ne peut ouvrir %s\n"

#: src/detect.c:189
#, c-format
msgid "IR length: %d\n"
msgstr "longueur IR: %d\n"

#: src/detect.c:205
msgid "Unable to detect JTAG chain length\n"
msgstr "Incapable de détecter la longueur de la chaîne JTAG\n"

#: src/detect.c:208
#, c-format
msgid "Chain length: %d\n"
msgstr "Longueur de la chaîne: %d\n"

#: src/detect.c:249
#, c-format
msgid "Device Id: %s\n"
msgstr "Identificateur du périphérique: %s\n"

#: src/detect.c:270
msgid "  Unknown manufacturer!\n"
msgstr "  Manufacturier inconnu!\n"

#: src/detect.c:276
#, c-format
msgid "  Manufacturer: %s\n"
msgstr "  Manufacturier: %s\n"

#: src/detect.c:278
msgid "Warning: Manufacturer too long\n"
msgstr "AVERTISSEMENT: nom du manufacturier trop long\n"

#: src/detect.c:294
msgid "  Unknown part!\n"
msgstr "  Pièce inconnue!\n"

#: src/detect.c:300
#, c-format
msgid "  Part:         %s\n"
msgstr "  Pièce:         %s\n"

#: src/detect.c:302
msgid "Warning: Part too long\n"
msgstr "AVERTISSEMENT: nom de pièce trop long\n"

#: src/detect.c:318
msgid "  Unknown stepping!\n"
msgstr "  Pas inconnu!\n"

#: src/detect.c:324
#, c-format
msgid "  Stepping:     %s\n"
msgstr "  Pas     :     %s\n"

#: src/detect.c:326
msgid "Warning: Stepping too long\n"
msgstr "AVERTISSEMENT: pas trop long\n"

#: src/detect.c:338
#, c-format
msgid "  Filename:     %s\n"
msgstr "  nom de fichier:     %s\n"

#: src/detect.c:353
msgid "Error: Unable to detect JTAG chain end!\n"
msgstr "ERREUR: incapable de détecter la fin de la chaîne JTAG!\n"

#: src/discovery.c:113
msgid "Detecting IR length ... "
msgstr "Détection de la longuer IR..."

#: src/discovery.c:119 src/discovery.c:151
#, c-format
msgid "%d\n"
msgstr "%d\n"

#: src/discovery.c:122
msgid "Error: Invalid IR length!\n"
msgstr "ERREUR: longueur IR invalide!\n"

#: src/discovery.c:133
msgid "Error: Out of memory!\n"
msgstr "ERREUR: mémoire épuisée!\n"

#: src/discovery.c:145
#, c-format
msgid "Detecting DR length for IR %s ... "
msgstr "Détection de la longeur DR de IR %s..."

#: src/flash.c:82
#, c-format
msgid "unknown flash - vendor id: %d (0x%04x)\n"
msgstr "flahs inconnu - identificateur du manufacturier: %d (0x%04x)\n"

#: src/flash.c:95
msgid "Note: Supported configuration is 2 x 16 bit or 1 x 16 bit only\n"
msgstr "Note: configuration supportés sont 2 x 16 bits ou 1 x 16 bits seulement\n"

#: src/flash.c:106
msgid "Flash not supported!\n"
msgstr "Flash non supporté!\n"

#: src/flash.c:121 src/flash.c:269 src/flash.c:378
msgid "no flash driver found\n"
msgstr "aucun pilote de flahs repéré\n"

#: src/flash.c:132
msgid "Invalid sync sequence!\n"
msgstr "Séquence de synchro invalide!\n"

#: src/flash.c:150 src/flash.c:390
#, c-format
msgid "block %d unlocked\n"
msgstr "bloc %d déverrouillé\n"

#: src/flash.c:151 src/flash.c:297 src/flash.c:391
#, c-format
msgid "erasing block %d: %d\n"
msgstr "effacement du bloc %d: %d\n"

#: src/flash.c:155 src/flash.c:285 src/flash.c:383
msgid "program:\n"
msgstr "programme:\n"

#: src/flash.c:163 src/flash.c:203
msgid "Error: premature end of file\n"
msgstr "ERREUR: fin prématurée du fichier\n"

#: src/flash.c:166 src/flash.c:206
#, c-format
msgid "record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n"
msgstr "enregistrement: début = 0x%08X, longueur = 0x%08X, checksum = 0x%08X\n"

#: src/flash.c:170 src/flash.c:210
msgid "Error: Invalid record length!\n"
msgstr "ERREUR: longueur de l'enregistrement invalide!\n"

#: src/flash.c:177 src/flash.c:217 src/flash.c:304 src/flash.c:350
#: src/readmem.c:102
#, c-format
msgid "addr: 0x%08X"
msgstr "adr: 0x%08X"

#: src/flash.c:182 src/flash.c:316
msgid ""
"\n"
"flash error\n"
msgstr ""
"\n"
"erreur flash\n"

#: src/flash.c:194 src/flash.c:327
msgid "verify:\n"
msgstr "vérifier:\n"

#: src/flash.c:223
#, c-format
msgid ""
"\n"
"verify error: 0x%08X vs. 0x%08X at addr %08X\n"
msgstr ""
"\n"
"ERREUR de vérification: 0x%08X vs. 0x%08X à l'adresse %08X\n"

#: src/flash.c:232 src/flash.c:360 src/flash.c:396 src/readmem.c:109
msgid ""
"\n"
"Done.\n"
msgstr ""
"\n"
"Complété.\n"

#: src/flash.c:279
msgid "Out of memory!\n"
msgstr "Mémoire épuisée!\n"

#: src/flash.c:296
#, c-format
msgid ""
"\n"
"block %d unlocked\n"
msgstr ""
"\n"
"bloc %d déverrouillé\n"

#: src/flash.c:339
msgid "Error during file read.\n"
msgstr "ERREUR durant la lecture du fichier.\n"

#: src/flash.c:355
#, c-format
msgid ""
"\n"
"verify error:\n"
"readed: 0x%08X\n"
"expected: 0x%08X\n"
msgstr ""
"\n"
"ERREUR de vérification:\n"
"lu: 0x%08X\n"
"attendu: 0x%08X\n"

#: src/flash.c:374 src/flash.c:387
#, c-format
msgid "addr: 0x%08X\n"
msgstr "adr: 0x%08X\n"

#: src/jtag.c:261
#, c-format
msgid ""
"%s\n"
"Copyright (C) 2002, 2003 ETC s.r.o.\n"
"%s is free software, covered by the GNU General Public License, and you are\n"
"welcome to change it and/or distribute copies of it under certain conditions.\n"
"There is absolutely no warranty for %s.\n"
"\n"
msgstr ""
"%s\n"
"Copyright © 2002, 2003 ETC s.r.o.\n"
"%s est un logiciel libre; vous pouvez le redistribuer ou le\n"
"modifier selon les termes de la License Publique Générale de GNU, publiée\n"
"par la Free Software Foundation (soit la version 2 ou selon votre choix, toute version ultérieure).\n"
"\n"
"Ce programme est distribué dans l'espoir qu'il soit utile,\n"
"mais AUCUNE garantie n'est donnée pour %s\n"
"tant pour des raisons COMMERCIALES que\n"
"pour RÉPONDRE À UN BESOIN PARTICULIER.  Consulter la licence\n"
"GNU General Public License pour plus de détails.\n"
"\n"
"Vous devriez avoir reçu copie de la Licence Publique Générale de GNU\n"
"avec ce programme; sinon, écrire à la Free Software Foundation, Inc.,\n"
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"

#: src/jtag.c:274
#, c-format
msgid ""
"Warning: %s may damage your hardware! Type \"quit\" to exit!\n"
"\n"
msgstr ""
"AVERTISSEMENT: %s peut endommager votre matériel! Taper \"quit\" pour quitter!\n"
"\n"

#: src/jtag.c:275
msgid ""
"Type \"help\" for help.\n"
"\n"
msgstr ""
"Taper \"help\" pour de l'aide.\n"
"\n"

#: src/part/data_register.c:46
msgid "Warning: Data register name too long\n"
msgstr "AVERTISSEMENT: nom du registre de données trop long\n"

#: src/part/instruction.c:46
msgid "Warning: Instruction name too long\n"
msgstr "AVERTISSEMENT: nom de l'instruction trop long\n"

#: src/part/part.c:168 src/part/part.c:205
#, c-format
msgid "%s(%s:%d) Boundary Scan Register (BSR) not found\n"
msgstr "%s(%s:%d) Boundary Scan Register (BSR) non repéré\n"

#: src/part/part.c:176
#, c-format
msgid "signal '%s' cannot be set as output\n"
msgstr "signal '%s' ne peut être initialisé comme sortie\n"

#: src/part/part.c:186
#, c-format
msgid "signal '%s' cannot be set as input\n"
msgstr "signal '%s' ne peut être initialisé comme entrée\n"

#: src/part/part.c:210
#, c-format
msgid "signal '%s' is not input signal\n"
msgstr "signal '%s' n'est pas un signal d'entrée\n"

#: src/part/part.c:227
#, c-format
msgid "%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"
msgstr "%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n"

#: src/part/part.c:236 src/part/part.c:238
msgid "(none)"
msgstr "(aucun)"

#: src/readmem.c:61
msgid "Error: Bus width detection failed\n"
msgstr "ERREUR: détection de la largeur de bus a échoué\n"

#: src/readmem.c:67
msgid "Unknown bus width!\n"
msgstr "Largeur de bus inconnu!\n"

#: src/readmem.c:74
#, c-format
msgid "address: 0x%08X\n"
msgstr "adresse: 0x%08X\n"

#: src/readmem.c:75
#, c-format
msgid "length:  0x%08X\n"
msgstr "longueur:  0x%08X\n"

#: src/readmem.c:78
msgid "length is 0.\n"
msgstr "longeur est 0.\n"

#: src/readmem.c:82
msgid "reading:\n"
msgstr "lecture en cours:\n"

#: src/tap/cable/arcom.c:100
msgid "Arcom JTAG Cable"
msgstr "Cable JTAG Arcom"

#: src/tap/cable/byteblaster.c:126
msgid "Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable"
msgstr "Cable du port parallèle de chargement Altera ByteBlaster/ByteBlaster II/ByteBlasterMV"

#: src/tap/cable/dlc5.c:97
msgid "Xilinx DLC5 JTAG Parallel Cable III"
msgstr "Cable parallèle JTAG Xilinx DLC5 III"

#: src/tap/cable/ea253.c:100
msgid "ETC EA253 JTAG Cable"
msgstr "Cable JATB ETC EA253"

#: src/tap/cable/ei012.c:102
msgid "ETC EI012 JTAG Cable"
msgstr "Cable JTAG ETC EI012"

#: src/tap/cable/keithkoep.c:109
msgid "Keith & Koep JTAG cable"
msgstr "Cable JTAG Keith & Koep"

#: src/tap/cable/mpcbdm.c:106
msgid "Mpcbdm JTAG cable"
msgstr "Cable JTAG Mpcbdm"

#: src/tap/cable/triton.c:111
msgid "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable"
msgstr "Cable JTAG Ka-Ro TRITON Starterkit II (PXA255/250)"

#: src/tap/cable/wiggler.c:104
msgid "Macraigor Wiggler JTAG Cable"
msgstr "Cable JTAG Macraigor Wiggler"

#: src/tap/chain.c:110 src/tap/chain.c:133
#, c-format
msgid "%s(%d) Part %d without active instruction\n"
msgstr "%s(%d) pièce %d sans instruction active\n"

#: src/tap/chain.c:137
#, c-format
msgid "%s(%d) Part %d without data register\n"
msgstr "%s(%d) pièce %d sans registre de données\n"

#: src/tap/parport/direct.c:161 src/tap/parport/ppdev.c:118
msgid "Syntax error!\n"
msgstr "ERREUR de syntaxe!\n"

#: src/tap/parport/direct.c:166
msgid "Invalid port address!\n"
msgstr "Adresse de port invalide!\n"

#: src/tap/parport/direct.c:176
#, c-format
msgid "Disconnecting %s from parallel port at 0x%x\n"
msgstr "Déconnexion de %s du port parallèle à 0x%x\n"

#: src/tap/parport/direct.c:183 src/tap/parport/ppdev.c:130
msgid "Changed cable to 'none'\n"
msgstr "Cable changé pour 'aucun'\n"

#: src/tap/parport/direct.c:192 src/tap/parport/ppdev.c:139
#, c-format
msgid "Unknown cable: %s\n"
msgstr "Cable inconnue: %s\n"

#: src/tap/parport/direct.c:196
#, c-format
msgid "Initializing %s on parallel port at 0x%x\n"
msgstr "Initialisation de %s sur le port parallèle à 0x%x\n"

#: src/tap/parport/direct.c:200 src/tap/parport/ppdev.c:147
#, c-format
msgid "%s(%d) Out of memory.\n"
msgstr "%s(%d) Mémoire épuisée.\n"

#: src/tap/parport/ppdev.c:124
#, c-format
msgid "Disconnecting %s from ppdev port %s\n"
msgstr "Déconnexion de %s du port ppdev %s\n"

#: src/tap/parport/ppdev.c:143
#, c-format
msgid "Initializing %s on ppdev port %s\n"
msgstr "Initialisation de %s sur le port ppdev %s\n"

#: src/tap/tap.c:54 src/tap/tap.c:75 src/tap/tap.c:86
#, c-format
msgid "%s: Invalid state: %2X\n"
msgstr "%s: état invalide: %2X\n"
